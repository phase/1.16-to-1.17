--- net/minecraft/server/MinecraftServer.java
+++ net/minecraft/server/MinecraftServer.java
@@ -11,10 +11,11 @@
 import com.mojang.datafixers.DataFixer;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufOutputStream;
 import io.netty.buffer.Unpooled;
 import it.unimi.dsi.fastutil.longs.LongIterator;
+import java.awt.GraphicsEnvironment;
 import java.awt.image.BufferedImage;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
@@ -48,17 +49,19 @@
 import java.util.Map.Entry;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.BooleanSupplier;
+import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
 import net.minecraft.CrashReport;
 import net.minecraft.ReportedException;
 import net.minecraft.SharedConstants;
+import net.minecraft.SystemReport;
 import net.minecraft.Util;
 import net.minecraft.commands.CommandSource;
 import net.minecraft.commands.CommandSourceStack;
 import net.minecraft.commands.Commands;
 import net.minecraft.core.BlockPos;
@@ -71,24 +74,28 @@
 import net.minecraft.network.chat.TextComponent;
 import net.minecraft.network.chat.TranslatableComponent;
 import net.minecraft.network.protocol.game.ClientboundChangeDifficultyPacket;
 import net.minecraft.network.protocol.game.ClientboundSetTimePacket;
 import net.minecraft.network.protocol.status.ServerStatus;
+import net.minecraft.obfuscate.DontObfuscate;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.bossevents.CustomBossEvents;
+import net.minecraft.server.level.DemoMode;
 import net.minecraft.server.level.PlayerRespawnLogic;
 import net.minecraft.server.level.ServerChunkCache;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.level.ServerPlayerGameMode;
 import net.minecraft.server.level.TicketType;
 import net.minecraft.server.level.progress.ChunkProgressListener;
 import net.minecraft.server.level.progress.ChunkProgressListenerFactory;
 import net.minecraft.server.network.ServerConnectionListener;
 import net.minecraft.server.network.TextFilter;
 import net.minecraft.server.packs.repository.Pack;
 import net.minecraft.server.packs.repository.PackRepository;
+import net.minecraft.server.packs.resources.ResourceManager;
 import net.minecraft.server.players.GameProfileCache;
 import net.minecraft.server.players.PlayerList;
 import net.minecraft.server.players.ServerOpListEntry;
 import net.minecraft.server.players.UserWhiteList;
 import net.minecraft.tags.BlockTags;
@@ -97,15 +104,20 @@
 import net.minecraft.util.CryptException;
 import net.minecraft.util.FrameTimer;
 import net.minecraft.util.Mth;
 import net.minecraft.util.ProgressListener;
 import net.minecraft.util.Unit;
-import net.minecraft.util.profiling.ContinuousProfiler;
-import net.minecraft.util.profiling.InactiveProfiler;
+import net.minecraft.util.profiling.EmptyProfileResults;
 import net.minecraft.util.profiling.ProfileResults;
 import net.minecraft.util.profiling.ProfilerFiller;
+import net.minecraft.util.profiling.ResultField;
 import net.minecraft.util.profiling.SingleTickProfiler;
+import net.minecraft.util.profiling.metrics.profiling.ActiveMetricsRecorder;
+import net.minecraft.util.profiling.metrics.profiling.InactiveMetricsRecorder;
+import net.minecraft.util.profiling.metrics.profiling.MetricsRecorder;
+import net.minecraft.util.profiling.metrics.profiling.ServerMetricsSamplersProvider;
+import net.minecraft.util.profiling.metrics.storage.MetricsPersister;
 import net.minecraft.util.thread.ReentrantBlockableEventLoop;
 import net.minecraft.world.Difficulty;
 import net.minecraft.world.Snooper;
 import net.minecraft.world.SnooperPopulator;
 import net.minecraft.world.entity.Entity;
@@ -127,44 +139,67 @@
 import net.minecraft.world.level.border.BorderChangeListener;
 import net.minecraft.world.level.border.WorldBorder;
 import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.dimension.DimensionType;
 import net.minecraft.world.level.dimension.LevelStem;
+import net.minecraft.world.level.levelgen.Heightmap;
 import net.minecraft.world.level.levelgen.PatrolSpawner;
 import net.minecraft.world.level.levelgen.PhantomSpawner;
 import net.minecraft.world.level.levelgen.WorldGenSettings;
 import net.minecraft.world.level.levelgen.feature.ConfiguredFeature;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureManager;
-import net.minecraft.world.level.saveddata.SaveDataDirtyRunnable;
 import net.minecraft.world.level.storage.CommandStorage;
 import net.minecraft.world.level.storage.DerivedLevelData;
 import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelData;
 import net.minecraft.world.level.storage.LevelResource;
 import net.minecraft.world.level.storage.LevelStorageSource;
 import net.minecraft.world.level.storage.PlayerDataStorage;
 import net.minecraft.world.level.storage.ServerLevelData;
 import net.minecraft.world.level.storage.WorldData;
+import net.minecraft.world.level.storage.loot.ItemModifierManager;
 import net.minecraft.world.level.storage.loot.LootTables;
 import net.minecraft.world.level.storage.loot.PredicateManager;
 import net.minecraft.world.phys.Vec2;
 import net.minecraft.world.phys.Vec3;
-import net.minecraft.world.scores.ScoreboardSaveData;
 import org.apache.commons.lang3.Validate;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements SnooperPopulator, CommandSource, AutoCloseable {
-   private static final Logger LOGGER = LogManager.getLogger();
+   static final Logger LOGGER = LogManager.getLogger();
+   private static final float AVERAGE_TICK_TIME_SMOOTHING = 0.8F;
+   private static final int TICK_STATS_SPAN = 100;
+   public static final int MS_PER_TICK = 50;
+   private static final int SNOOPER_UPDATE_INTERVAL = 6000;
+   private static final int OVERLOADED_THRESHOLD = 2000;
+   private static final int OVERLOADED_WARNING_INTERVAL = 15000;
+   public static final String LEVEL_STORAGE_PROTOCOL = "level";
+   public static final String LEVEL_STORAGE_SCHEMA = "level://";
+   private static final long STATUS_EXPIRE_TIME_NS = 5000000000L;
+   private static final int MAX_STATUS_PLAYER_SAMPLE = 12;
+   public static final String MAP_RESOURCE_FILE = "resources.zip";
    public static final File USERID_CACHE_FILE = new File("usercache.json");
+   public static final int START_CHUNK_RADIUS = 11;
+   private static final int START_TICKING_CHUNK_COUNT = 441;
+   private static final int AUTOSAVE_INTERVAL = 6000;
+   private static final int MAX_TICK_LATENCY = 3;
+   public static final int ABSOLUTE_MAX_WORLD_SIZE = 29999984;
    public static final LevelSettings DEMO_SETTINGS;
+   private static final long DELAYED_TASKS_TICK_EXTENSION = 50L;
    protected final LevelStorageSource.LevelStorageAccess storageSource;
    protected final PlayerDataStorage playerDataStorage;
    private final Snooper snooper = new Snooper("server", this, Util.getMillis());
    private final List<Runnable> tickables = Lists.newArrayList();
-   private final ContinuousProfiler continousProfiler;
+   private MetricsRecorder metricsRecorder;
    private ProfilerFiller profiler;
+   private Consumer<ProfileResults> onMetricsRecordingStopped;
+   private Consumer<Path> onMetricsRecordingFinished;
+   private boolean willStartRecordingMetrics;
+   @Nullable
+   private MinecraftServer.TimeProfiler debugCommandProfiler;
+   private boolean debugCommandProfilerDelayStart;
    private final ServerConnectionListener connection;
    private final ChunkProgressListenerFactory progressListenerFactory;
    private final ServerStatus status;
    private final Random random;
    private final DataFixer fixerUpper;
@@ -181,11 +216,10 @@
    private boolean preventProxyConnections;
    private boolean pvp;
    private boolean allowFlight;
    @Nullable
    private String motd;
-   private int maxBuildHeight;
    private int playerIdleTimeout;
    public final long[] tickTimes;
    @Nullable
    private KeyPair keyPair;
    @Nullable
@@ -193,14 +227,14 @@
    private boolean isDemo;
    private String resourcePack;
    private String resourcePackHash;
    private volatile boolean isReady;
    private long lastOverloadWarning;
-   private boolean delayProfilerStart;
-   private boolean forceGameType;
    private final MinecraftSessionService sessionService;
+   @Nullable
    private final GameProfileRepository profileRepository;
+   @Nullable
    private final GameProfileCache profileCache;
    private long lastServerStatus;
    private final Thread serverThread;
    private long nextTickTime;
    private long delayedTasksMaxNextTickTime;
@@ -234,14 +268,19 @@
       var1.set(var3);
       var2.start();
       return var3;
    }
 
-   public MinecraftServer(Thread var1, RegistryAccess.RegistryHolder var2, LevelStorageSource.LevelStorageAccess var3, WorldData var4, PackRepository var5, Proxy var6, DataFixer var7, ServerResources var8, MinecraftSessionService var9, GameProfileRepository var10, GameProfileCache var11, ChunkProgressListenerFactory var12) {
+   public MinecraftServer(Thread var1, RegistryAccess.RegistryHolder var2, LevelStorageSource.LevelStorageAccess var3, WorldData var4, PackRepository var5, Proxy var6, DataFixer var7, ServerResources var8, @Nullable MinecraftSessionService var9, @Nullable GameProfileRepository var10, @Nullable GameProfileCache var11, ChunkProgressListenerFactory var12) {
       super("Server");
-      this.continousProfiler = new ContinuousProfiler(Util.timeSource, this::getTickCount);
-      this.profiler = InactiveProfiler.INSTANCE;
+      this.metricsRecorder = InactiveMetricsRecorder.INSTANCE;
+      this.profiler = this.metricsRecorder.getProfiler();
+      this.onMetricsRecordingStopped = (var1x) -> {
+         this.stopRecordingMetrics();
+      };
+      this.onMetricsRecordingFinished = (var0) -> {
+      };
       this.status = new ServerStatus();
       this.random = new Random();
       this.port = -1;
       this.levels = Maps.newLinkedHashMap();
       this.running = true;
@@ -258,10 +297,14 @@
       this.packRepository = var5;
       this.resources = var8;
       this.sessionService = var9;
       this.profileRepository = var10;
       this.profileCache = var11;
+      if (var11 != null) {
+         var11.setExecutor(this);
+      }
+
       this.connection = new ServerConnectionListener(this);
       this.progressListenerFactory = var12;
       this.storageSource = var3;
       this.playerDataStorage = var3.createPlayerStorage();
       this.fixerUpper = var7;
@@ -270,13 +313,16 @@
       this.serverThread = var1;
       this.executor = Util.backgroundExecutor();
    }
 
    private void readScoreboard(DimensionDataStorage var1) {
-      ScoreboardSaveData var2 = (ScoreboardSaveData)var1.computeIfAbsent(ScoreboardSaveData::new, "scoreboard");
-      var2.setScoreboard(this.getScoreboard());
-      this.getScoreboard().addDirtyListener(new SaveDataDirtyRunnable(var2));
+      ServerScoreboard var10001 = this.getScoreboard();
+      Objects.requireNonNull(var10001);
+      Function var2 = var10001::createData;
+      ServerScoreboard var10002 = this.getScoreboard();
+      Objects.requireNonNull(var10002);
+      var1.computeIfAbsent(var2, var10002::createData, "scoreboard");
    }
 
    protected abstract boolean initServer() throws IOException;
 
    public static void convertFromRegionFormatIfNeeded(LevelStorageSource.LevelStorageAccess var0) {
@@ -331,11 +377,11 @@
       MappedRegistry var10 = var3.dimensions();
       LevelStem var12 = (LevelStem)var10.get(LevelStem.OVERWORLD);
       Object var11;
       DimensionType var13;
       if (var12 == null) {
-         var13 = (DimensionType)this.registryHolder.dimensionTypes().getOrThrow(DimensionType.OVERWORLD_LOCATION);
+         var13 = (DimensionType)this.registryHolder.registryOrThrow(Registry.DIMENSION_TYPE_REGISTRY).getOrThrow(DimensionType.OVERWORLD_LOCATION);
          var11 = WorldGenSettings.makeDefaultOverworld(this.registryHolder.registryOrThrow(Registry.BIOME_REGISTRY), this.registryHolder.registryOrThrow(Registry.NOISE_GENERATOR_SETTINGS_REGISTRY), (new Random()).nextLong());
       } else {
          var13 = var12.type();
          var11 = var12.generator();
       }
@@ -347,11 +393,11 @@
       this.commandStorage = new CommandStorage(var15);
       WorldBorder var16 = var14.getWorldBorder();
       var16.applySettings(var2.getWorldBorder());
       if (!var2.isInitialized()) {
          try {
-            setInitialSpawn(var14, var2, var3.generateBonusChest(), var4, true);
+            setInitialSpawn(var14, var2, var3.generateBonusChest(), var4);
             var2.setInitialized(true);
             if (var4) {
                this.setupDebugLevel(this.worldData);
             }
          } catch (Throwable var26) {
@@ -389,67 +435,71 @@
          }
       }
 
    }
 
-   private static void setInitialSpawn(ServerLevel var0, ServerLevelData var1, boolean var2, boolean var3, boolean var4) {
-      ChunkGenerator var5 = var0.getChunkSource().getGenerator();
-      if (!var4) {
-         var1.setSpawn(BlockPos.ZERO.above(var5.getSpawnHeight()), 0.0F);
-      } else if (var3) {
-         var1.setSpawn(BlockPos.ZERO.above(), 0.0F);
+   private static void setInitialSpawn(ServerLevel var0, ServerLevelData var1, boolean var2, boolean var3) {
+      if (var3) {
+         var1.setSpawn(BlockPos.ZERO.above(80), 0.0F);
       } else {
-         BiomeSource var6 = var5.getBiomeSource();
-         Random var7 = new Random(var0.getSeed());
-         BlockPos var8 = var6.findBiomeHorizontal(0, var0.getSeaLevel(), 0, 256, (var0x) -> {
+         ChunkGenerator var4 = var0.getChunkSource().getGenerator();
+         BiomeSource var5 = var4.getBiomeSource();
+         Random var6 = new Random(var0.getSeed());
+         BlockPos var7 = var5.findBiomeHorizontal(0, var0.getSeaLevel(), 0, 256, (var0x) -> {
             return var0x.getMobSettings().playerSpawnFriendly();
-         }, var7);
-         ChunkPos var9 = var8 == null ? new ChunkPos(0, 0) : new ChunkPos(var8);
-         if (var8 == null) {
+         }, var6);
+         ChunkPos var8 = var7 == null ? new ChunkPos(0, 0) : new ChunkPos(var7);
+         if (var7 == null) {
             LOGGER.warn("Unable to find spawn biome");
          }
 
-         boolean var10 = false;
-         Iterator var11 = BlockTags.VALID_SPAWN.getValues().iterator();
+         boolean var9 = false;
+         Iterator var10 = BlockTags.VALID_SPAWN.getValues().iterator();
 
-         while(var11.hasNext()) {
-            Block var12 = (Block)var11.next();
-            if (var6.getSurfaceBlocks().contains(var12.defaultBlockState())) {
-               var10 = true;
+         while(var10.hasNext()) {
+            Block var11 = (Block)var10.next();
+            if (var5.getSurfaceBlocks().contains(var11.defaultBlockState())) {
+               var9 = true;
                break;
             }
          }
 
-         var1.setSpawn(var9.getWorldPosition().offset(8, var5.getSpawnHeight(), 8), 0.0F);
-         int var18 = 0;
-         int var19 = 0;
+         int var18 = var4.getSpawnHeight(var0);
+         if (var18 < var0.getMinBuildHeight()) {
+            BlockPos var19 = var8.getWorldPosition();
+            var18 = var0.getHeight(Heightmap.Types.WORLD_SURFACE, var19.getX() + 8, var19.getZ() + 8);
+         }
+
+         var1.setSpawn(var8.getWorldPosition().offset(8, var18, 8), 0.0F);
+         int var20 = 0;
+         int var12 = 0;
          int var13 = 0;
          int var14 = -1;
          boolean var15 = true;
 
          for(int var16 = 0; var16 < 1024; ++var16) {
-            if (var18 > -16 && var18 <= 16 && var19 > -16 && var19 <= 16) {
-               BlockPos var17 = PlayerRespawnLogic.getSpawnPosInChunk(var0, new ChunkPos(var9.x + var18, var9.z + var19), var10);
+            if (var20 > -16 && var20 <= 16 && var12 > -16 && var12 <= 16) {
+               BlockPos var17 = PlayerRespawnLogic.getSpawnPosInChunk(var0, new ChunkPos(var8.x + var20, var8.z + var12), var9);
                if (var17 != null) {
                   var1.setSpawn(var17, 0.0F);
                   break;
                }
             }
 
-            if (var18 == var19 || var18 < 0 && var18 == -var19 || var18 > 0 && var18 == 1 - var19) {
-               int var21 = var13;
+            if (var20 == var12 || var20 < 0 && var20 == -var12 || var20 > 0 && var20 == 1 - var12) {
+               int var22 = var13;
                var13 = -var14;
-               var14 = var21;
+               var14 = var22;
             }
 
-            var18 += var13;
-            var19 += var14;
+            var20 += var13;
+            var12 += var14;
          }
 
          if (var2) {
-            ConfiguredFeature var20 = Features.BONUS_CHEST;
-            var20.place(var0, var5, var0.random, new BlockPos(var1.getXSpawn(), var1.getYSpawn(), var1.getZSpawn()));
+            ConfiguredFeature var21 = Features.BONUS_CHEST;
+            var21.place(var0, var4, var0.random, new BlockPos(var1.getXSpawn(), var1.getYSpawn(), var1.getZSpawn()));
          }
 
       }
    }
 
@@ -495,11 +545,11 @@
                this.updateMobSpawningFlags();
                return;
             }
 
             var6 = (ServerLevel)var5.next();
-            var7 = (ForcedChunksSavedData)var6.getDataStorage().get(ForcedChunksSavedData::new, "chunks");
+            var7 = (ForcedChunksSavedData)var6.getDataStorage().get(ForcedChunksSavedData::load, "chunks");
          } while(var7 == null);
 
          LongIterator var8 = var7.getChunks().iterator();
 
          while(var8.hasNext()) {
@@ -514,11 +564,11 @@
       File var1 = this.storageSource.getLevelPath(LevelResource.MAP_RESOURCE_FILE).toFile();
       if (var1.isFile()) {
          String var2 = this.storageSource.getLevelId();
 
          try {
-            this.setResourcePack("level://" + URLEncoder.encode(var2, StandardCharsets.UTF_8.toString()) + "/" + "resources.zip", "");
+            this.setResourcePack("level://" + URLEncoder.encode(var2, StandardCharsets.UTF_8.toString()) + "/resources.zip", "");
          } catch (UnsupportedEncodingException var4) {
             LOGGER.warn("Something went wrong url encoding {}", var2);
          }
       }
 
@@ -560,11 +610,11 @@
 
    public void close() {
       this.stopServer();
    }
 
-   protected void stopServer() {
+   public void stopServer() {
       LOGGER.info("Stopping server");
       if (this.getConnection() != null) {
          this.getConnection().stop();
       }
 
@@ -652,38 +702,44 @@
                   LOGGER.warn("Can't keep up! Is the server overloaded? Running {}ms or {} ticks behind", var1, var46);
                   this.nextTickTime += var46 * 50L;
                   this.lastOverloadWarning = this.nextTickTime;
                }
 
+               if (this.debugCommandProfilerDelayStart) {
+                  this.debugCommandProfilerDelayStart = false;
+                  this.debugCommandProfiler = new MinecraftServer.TimeProfiler(Util.getNanos(), this.tickCount);
+               }
+
                this.nextTickTime += 50L;
-               SingleTickProfiler var47 = SingleTickProfiler.createTickProfiler("Server");
-               this.startProfilerTick(var47);
-               this.profiler.startTick();
+               this.startMetricsRecordingTick();
                this.profiler.push("tick");
                this.tickServer(this::haveTime);
                this.profiler.popPush("nextTickWait");
                this.mayHaveDelayedTasks = true;
                this.delayedTasksMaxNextTickTime = Math.max(Util.getMillis() + 50L, this.nextTickTime);
                this.waitUntilNextTick();
                this.profiler.pop();
-               this.profiler.endTick();
-               this.endProfilerTick(var47);
+               this.endMetricsRecordingTick();
                this.isReady = true;
             }
          } else {
             this.onServerCrash((CrashReport)null);
          }
       } catch (Throwable var44) {
          LOGGER.error("Encountered an unexpected exception", var44);
          CrashReport var2;
          if (var44 instanceof ReportedException) {
-            var2 = this.fillReport(((ReportedException)var44).getReport());
+            var2 = ((ReportedException)var44).getReport();
          } else {
-            var2 = this.fillReport(new CrashReport("Exception in server tick loop", var44));
+            var2 = new CrashReport("Exception in server tick loop", var44);
          }
 
-         File var3 = new File(new File(this.getServerDirectory(), "crash-reports"), "crash-" + (new SimpleDateFormat("yyyy-MM-dd_HH.mm.ss")).format(new Date()) + "-server.txt");
+         this.fillSystemReport(var2.getSystemReport());
+         File var10002 = new File(this.getServerDirectory(), "crash-reports");
+         SimpleDateFormat var10003 = new SimpleDateFormat("yyyy-MM-dd_HH.mm.ss");
+         Date var10004 = new Date();
+         File var3 = new File(var10002, "crash-" + var10003.format(var10004) + "-server.txt");
          if (var2.saveToFile(var3)) {
             LOGGER.error("This crash report has been saved to: {}", var3.getAbsolutePath());
          } else {
             LOGGER.error("We were unable to save this crash report to disk.");
          }
@@ -791,14 +847,14 @@
    }
 
    protected void onServerCrash(CrashReport var1) {
    }
 
-   protected void onServerExit() {
+   public void onServerExit() {
    }
 
-   protected void tickServer(BooleanSupplier var1) {
+   public void tickServer(BooleanSupplier var1) {
       long var2 = Util.getNanos();
       ++this.tickCount;
       this.tickChildren(var1);
       if (var2 - this.lastServerStatus >= 5000000000L) {
          this.lastServerStatus = var2;
@@ -839,11 +895,11 @@
       long var9 = Util.getNanos();
       this.frameTimer.logFrameDuration(var9 - var2);
       this.profiler.pop();
    }
 
-   protected void tickChildren(BooleanSupplier var1) {
+   public void tickChildren(BooleanSupplier var1) {
       this.profiler.push("commandFunctions");
       this.getFunctions().tick();
       this.profiler.popPush("levels");
       Iterator var2 = this.getAllLevels().iterator();
 
@@ -875,11 +931,11 @@
       this.profiler.popPush("connection");
       this.getConnection().tick();
       this.profiler.popPush("players");
       this.playerList.tick();
       if (SharedConstants.IS_RUNNING_IN_IDE) {
-         GameTestTicker.singleton.tick();
+         GameTestTicker.SINGLETON.tick();
       }
 
       this.profiler.popPush("server gui refresh");
 
       for(int var7 = 0; var7 < this.tickables.size(); ++var7) {
@@ -940,22 +996,24 @@
 
    public String[] getPlayerNames() {
       return this.playerList.getPlayerNamesArray();
    }
 
+   @DontObfuscate
    public String getServerModName() {
       return "vanilla";
    }
 
-   public CrashReport fillReport(CrashReport var1) {
+   public SystemReport fillSystemReport(SystemReport var1) {
       if (this.playerList != null) {
-         var1.getSystemDetails().setDetail("Player Count", () -> {
-            return this.playerList.getPlayerCount() + " / " + this.playerList.getMaxPlayers() + "; " + this.playerList.getPlayers();
+         var1.setDetail("Player Count", () -> {
+            int var10000 = this.playerList.getPlayerCount();
+            return var10000 + " / " + this.playerList.getMaxPlayers() + "; " + this.playerList.getPlayers();
          });
       }
 
-      var1.getSystemDetails().setDetail("Data Packs", () -> {
+      var1.setDetail("Data Packs", () -> {
          StringBuilder var1 = new StringBuilder();
          Iterator var2 = this.packRepository.getSelectedPacks().iterator();
 
          while(var2.hasNext()) {
             Pack var3 = (Pack)var2.next();
@@ -970,18 +1028,20 @@
          }
 
          return var1.toString();
       });
       if (this.serverId != null) {
-         var1.getSystemDetails().setDetail("Server Id", () -> {
+         var1.setDetail("Server Id", () -> {
             return this.serverId;
          });
       }
 
-      return var1;
+      return this.fillServerSystemReport(var1);
    }
 
+   public abstract SystemReport fillServerSystemReport(SystemReport var1);
+
    public abstract Optional<String> getModdedStatus();
 
    public void sendMessage(Component var1, UUID var2) {
       LOGGER.info(var1.getString());
    }
@@ -1050,11 +1110,11 @@
    private void sendDifficultyUpdate(ServerPlayer var1) {
       LevelData var2 = var1.getLevel().getLevelData();
       var1.connection.send(new ClientboundChangeDifficultyPacket(var2.getDifficulty(), var2.isDifficultyLocked()));
    }
 
-   protected boolean isSpawningMonsters() {
+   public boolean isSpawningMonsters() {
       return this.worldData.getDifficulty() != Difficulty.PEACEFUL;
    }
 
    public boolean isDemo() {
       return this.isDemo;
@@ -1098,19 +1158,30 @@
          if (var4 != null) {
             var1.setDynamicData("world[" + var2 + "][dimension]", var4.dimension().location());
             var1.setDynamicData("world[" + var2 + "][mode]", this.worldData.getGameType());
             var1.setDynamicData("world[" + var2 + "][difficulty]", var4.getDifficulty());
             var1.setDynamicData("world[" + var2 + "][hardcore]", this.worldData.isHardcore());
-            var1.setDynamicData("world[" + var2 + "][height]", this.maxBuildHeight);
+            var1.setDynamicData("world[" + var2 + "][height]", var4.getMaxBuildHeight());
             var1.setDynamicData("world[" + var2 + "][chunks_loaded]", var4.getChunkSource().getLoadedChunksCount());
             ++var2;
          }
       }
 
       var1.setDynamicData("worlds", var2);
    }
 
+   public void populateSnooperInitial(Snooper var1) {
+      var1.setFixedData("singleplayer", this.isSingleplayer());
+      var1.setFixedData("server_brand", this.getServerModName());
+      var1.setFixedData("gui_supported", GraphicsEnvironment.isHeadless() ? "headless" : "supported");
+      var1.setFixedData("dedicated", this.isDedicatedServer());
+   }
+
+   public boolean isSnooperEnabled() {
+      return true;
+   }
+
    public abstract boolean isDedicatedServer();
 
    public abstract int getRateLimitPacketsPerSecond();
 
    public boolean usesAuthentication() {
@@ -1163,18 +1234,10 @@
 
    public void setMotd(String var1) {
       this.motd = var1;
    }
 
-   public int getMaxBuildHeight() {
-      return this.maxBuildHeight;
-   }
-
-   public void setMaxBuildHeight(int var1) {
-      this.maxBuildHeight = var1;
-   }
-
    public boolean isStopped() {
       return this.stopped;
    }
 
    public PlayerList getPlayerList() {
@@ -1202,11 +1265,13 @@
 
    public boolean hasGui() {
       return false;
    }
 
-   public abstract boolean publishServer(GameType var1, boolean var2, int var3);
+   public boolean publishServer(@Nullable GameType var1, boolean var2, int var3) {
+      return false;
+   }
 
    public int getTickCount() {
       return this.tickCount;
    }
 
@@ -1220,22 +1285,18 @@
 
    public boolean isUnderSpawnProtection(ServerLevel var1, BlockPos var2, Player var3) {
       return false;
    }
 
-   public void setForceGameType(boolean var1) {
-      this.forceGameType = var1;
-   }
-
-   public boolean getForceGameType() {
-      return this.forceGameType;
-   }
-
    public boolean repliesToStatus() {
       return true;
    }
 
+   public Proxy getProxy() {
+      return this.proxy;
+   }
+
    public int getPlayerIdleTimeout() {
       return this.playerIdleTimeout;
    }
 
    public void setPlayerIdleTimeout(int var1) {
@@ -1300,14 +1361,14 @@
 
    public CompletableFuture<Void> reloadResources(Collection<String> var1) {
       CompletableFuture var2 = CompletableFuture.supplyAsync(() -> {
          Stream var10000 = var1.stream();
          PackRepository var10001 = this.packRepository;
-         var10001.getClass();
+         Objects.requireNonNull(var10001);
          return (ImmutableList)var10000.map(var10001::getPack).filter(Objects::nonNull).map(Pack::open).collect(ImmutableList.toImmutableList());
       }, this).thenCompose((var1x) -> {
-         return ServerResources.loadResources(var1x, this.isDedicatedServer() ? Commands.CommandSelection.DEDICATED : Commands.CommandSelection.INTEGRATED, this.getFunctionCompilationLevel(), this.executor, this);
+         return ServerResources.loadResources(var1x, this.registryHolder, this.isDedicatedServer() ? Commands.CommandSelection.DEDICATED : Commands.CommandSelection.INTEGRATED, this.getFunctionCompilationLevel(), this.executor, this);
       }).thenAcceptAsync((var2x) -> {
          this.resources.close();
          this.resources = var2x;
          this.packRepository.setSelected(var1);
          this.worldData.setDataPackConfig(getSelectedPacks(this.packRepository));
@@ -1316,10 +1377,11 @@
          this.getPlayerList().reloadResources();
          this.functionManager.replaceLibrary(this.resources.getFunctionLibrary());
          this.structureManager.onResourceManagerReload(this.resources.getResourceManager());
       }, this);
       if (this.isSameThread()) {
+         Objects.requireNonNull(var2);
          this.managedBlock(var2::isDone);
       }
 
       return var2;
    }
@@ -1408,10 +1470,12 @@
 
    public boolean acceptsFailure() {
       return true;
    }
 
+   public abstract boolean shouldInformAdmins();
+
    public RecipeManager getRecipeManager() {
       return this.resources.getRecipeManager();
    }
 
    public TagContainer getTags() {
@@ -1436,10 +1500,14 @@
 
    public PredicateManager getPredicateManager() {
       return this.resources.getPredicateManager();
    }
 
+   public ItemModifierManager getItemModifierManager() {
+      return this.resources.getItemModifierManager();
+   }
+
    public GameRules getGameRules() {
       return this.overworld().getGameRules();
    }
 
    public CustomBossEvents getCustomBossEvents() {
@@ -1483,223 +1551,201 @@
       return this.profiler;
    }
 
    public abstract boolean isSingleplayerOwner(GameProfile var1);
 
-   public void saveDebugReport(Path var1) throws IOException {
+   public void dumpServerProperties(Path var1) throws IOException {
+   }
+
+   private void saveDebugReport(Path var1) {
       Path var2 = var1.resolve("levels");
-      Iterator var3 = this.levels.entrySet().iterator();
 
-      while(var3.hasNext()) {
-         Entry var4 = (Entry)var3.next();
-         ResourceLocation var5 = ((ResourceKey)var4.getKey()).location();
-         Path var6 = var2.resolve(var5.getNamespace()).resolve(var5.getPath());
-         Files.createDirectories(var6);
-         ((ServerLevel)var4.getValue()).saveDebugReport(var6);
+      try {
+         Iterator var3 = this.levels.entrySet().iterator();
+
+         while(var3.hasNext()) {
+            Entry var4 = (Entry)var3.next();
+            ResourceLocation var5 = ((ResourceKey)var4.getKey()).location();
+            Path var6 = var2.resolve(var5.getNamespace()).resolve(var5.getPath());
+            Files.createDirectories(var6);
+            ((ServerLevel)var4.getValue()).saveDebugReport(var6);
+         }
+
+         this.dumpGameRules(var1.resolve("gamerules.txt"));
+         this.dumpClasspath(var1.resolve("classpath.txt"));
+         this.dumpMiscStats(var1.resolve("stats.txt"));
+         this.dumpThreads(var1.resolve("threads.txt"));
+         this.dumpServerProperties(var1.resolve("server.properties.txt"));
+      } catch (IOException var7) {
+         LOGGER.warn("Failed to save debug report", var7);
       }
 
-      this.dumpGameRules(var1.resolve("gamerules.txt"));
-      this.dumpClasspath(var1.resolve("classpath.txt"));
-      this.dumpCrashCategory(var1.resolve("example_crash.txt"));
-      this.dumpMiscStats(var1.resolve("stats.txt"));
-      this.dumpThreads(var1.resolve("threads.txt"));
    }
 
    private void dumpMiscStats(Path var1) throws IOException {
       BufferedWriter var2 = Files.newBufferedWriter(var1);
-      Throwable var3 = null;
 
       try {
          var2.write(String.format("pending_tasks: %d\n", this.getPendingTasksCount()));
          var2.write(String.format("average_tick_time: %f\n", this.getAverageTickTime()));
          var2.write(String.format("tick_times: %s\n", Arrays.toString(this.tickTimes)));
          var2.write(String.format("queue: %s\n", Util.backgroundExecutor()));
-      } catch (Throwable var12) {
-         var3 = var12;
-         throw var12;
-      } finally {
+      } catch (Throwable var6) {
          if (var2 != null) {
-            if (var3 != null) {
-               try {
-                  var2.close();
-               } catch (Throwable var11) {
-                  var3.addSuppressed(var11);
-               }
-            } else {
+            try {
                var2.close();
+            } catch (Throwable var5) {
+               var6.addSuppressed(var5);
             }
          }
 
+         throw var6;
       }
 
-   }
-
-   private void dumpCrashCategory(Path var1) throws IOException {
-      CrashReport var2 = new CrashReport("Server dump", new Exception("dummy"));
-      this.fillReport(var2);
-      BufferedWriter var3 = Files.newBufferedWriter(var1);
-      Throwable var4 = null;
-
-      try {
-         var3.write(var2.getFriendlyReport());
-      } catch (Throwable var13) {
-         var4 = var13;
-         throw var13;
-      } finally {
-         if (var3 != null) {
-            if (var4 != null) {
-               try {
-                  var3.close();
-               } catch (Throwable var12) {
-                  var4.addSuppressed(var12);
-               }
-            } else {
-               var3.close();
-            }
-         }
-
+      if (var2 != null) {
+         var2.close();
       }
 
    }
 
    private void dumpGameRules(Path var1) throws IOException {
       BufferedWriter var2 = Files.newBufferedWriter(var1);
-      Throwable var3 = null;
 
       try {
-         final ArrayList var4 = Lists.newArrayList();
-         final GameRules var5 = this.getGameRules();
+         final ArrayList var3 = Lists.newArrayList();
+         final GameRules var4 = this.getGameRules();
          GameRules.visitGameRuleTypes(new GameRules.GameRuleTypeVisitor() {
             public <T extends GameRules.Value<T>> void visit(GameRules.Key<T> var1, GameRules.Type<T> var2) {
-               var4.add(String.format("%s=%s\n", var1.getId(), var5.getRule(var1).toString()));
+               var3.add(String.format("%s=%s\n", var1.getId(), var4.getRule(var1)));
             }
          });
-         Iterator var6 = var4.iterator();
+         Iterator var5 = var3.iterator();
 
-         while(var6.hasNext()) {
-            String var7 = (String)var6.next();
-            var2.write(var7);
+         while(var5.hasNext()) {
+            String var6 = (String)var5.next();
+            var2.write(var6);
          }
-      } catch (Throwable var15) {
-         var3 = var15;
-         throw var15;
-      } finally {
+      } catch (Throwable var8) {
          if (var2 != null) {
-            if (var3 != null) {
-               try {
-                  var2.close();
-               } catch (Throwable var14) {
-                  var3.addSuppressed(var14);
-               }
-            } else {
+            try {
                var2.close();
+            } catch (Throwable var7) {
+               var8.addSuppressed(var7);
             }
          }
 
+         throw var8;
       }
 
+      if (var2 != null) {
+         var2.close();
+      }
+
    }
 
    private void dumpClasspath(Path var1) throws IOException {
       BufferedWriter var2 = Files.newBufferedWriter(var1);
-      Throwable var3 = null;
 
       try {
-         String var4 = System.getProperty("java.class.path");
-         String var5 = System.getProperty("path.separator");
-         Iterator var6 = Splitter.on(var5).split(var4).iterator();
+         String var3 = System.getProperty("java.class.path");
+         String var4 = System.getProperty("path.separator");
+         Iterator var5 = Splitter.on(var4).split(var3).iterator();
 
-         while(var6.hasNext()) {
-            String var7 = (String)var6.next();
-            var2.write(var7);
+         while(var5.hasNext()) {
+            String var6 = (String)var5.next();
+            var2.write(var6);
             var2.write("\n");
          }
-      } catch (Throwable var15) {
-         var3 = var15;
-         throw var15;
-      } finally {
+      } catch (Throwable var8) {
          if (var2 != null) {
-            if (var3 != null) {
-               try {
-                  var2.close();
-               } catch (Throwable var14) {
-                  var3.addSuppressed(var14);
-               }
-            } else {
+            try {
                var2.close();
+            } catch (Throwable var7) {
+               var8.addSuppressed(var7);
             }
          }
 
+         throw var8;
       }
 
+      if (var2 != null) {
+         var2.close();
+      }
+
    }
 
    private void dumpThreads(Path var1) throws IOException {
       ThreadMXBean var2 = ManagementFactory.getThreadMXBean();
       ThreadInfo[] var3 = var2.dumpAllThreads(true, true);
       Arrays.sort(var3, Comparator.comparing(ThreadInfo::getThreadName));
       BufferedWriter var4 = Files.newBufferedWriter(var1);
-      Throwable var5 = null;
 
       try {
-         ThreadInfo[] var6 = var3;
-         int var7 = var3.length;
+         ThreadInfo[] var5 = var3;
+         int var6 = var3.length;
 
-         for(int var8 = 0; var8 < var7; ++var8) {
-            ThreadInfo var9 = var6[var8];
-            var4.write(var9.toString());
+         for(int var7 = 0; var7 < var6; ++var7) {
+            ThreadInfo var8 = var5[var7];
+            var4.write(var8.toString());
             var4.write(10);
          }
-      } catch (Throwable var17) {
-         var5 = var17;
-         throw var17;
-      } finally {
+      } catch (Throwable var10) {
          if (var4 != null) {
-            if (var5 != null) {
-               try {
-                  var4.close();
-               } catch (Throwable var16) {
-                  var5.addSuppressed(var16);
-               }
-            } else {
+            try {
                var4.close();
+            } catch (Throwable var9) {
+               var10.addSuppressed(var9);
             }
          }
 
+         throw var10;
       }
 
+      if (var4 != null) {
+         var4.close();
+      }
+
    }
 
-   private void startProfilerTick(@Nullable SingleTickProfiler var1) {
-      if (this.delayProfilerStart) {
-         this.delayProfilerStart = false;
-         this.continousProfiler.enable();
+   private void startMetricsRecordingTick() {
+      if (this.willStartRecordingMetrics) {
+         this.metricsRecorder = ActiveMetricsRecorder.createStarted(new ServerMetricsSamplersProvider(Util.timeSource, this.isDedicatedServer()), Util.timeSource, Util.ioPool(), new MetricsPersister("server"), this.onMetricsRecordingStopped, (var1) -> {
+            this.saveDebugReport(var1.resolve("server"));
+            this.onMetricsRecordingFinished.accept(var1);
+         });
+         this.willStartRecordingMetrics = false;
       }
 
-      this.profiler = SingleTickProfiler.decorateFiller(this.continousProfiler.getFiller(), var1);
+      this.profiler = SingleTickProfiler.decorateFiller(this.metricsRecorder.getProfiler(), SingleTickProfiler.createTickProfiler("Server"));
+      this.metricsRecorder.startTick();
+      this.profiler.startTick();
    }
 
-   private void endProfilerTick(@Nullable SingleTickProfiler var1) {
-      if (var1 != null) {
-         var1.endTick();
-      }
+   private void endMetricsRecordingTick() {
+      this.profiler.endTick();
+      this.metricsRecorder.endTick();
+   }
 
-      this.profiler = this.continousProfiler.getFiller();
+   public boolean isRecordingMetrics() {
+      return this.metricsRecorder.isRecording();
    }
 
-   public boolean isProfiling() {
-      return this.continousProfiler.isEnabled();
+   public void startRecordingMetrics(Consumer<ProfileResults> var1, Consumer<Path> var2) {
+      this.onMetricsRecordingStopped = (var2x) -> {
+         this.stopRecordingMetrics();
+         var1.accept(var2x);
+      };
+      this.onMetricsRecordingFinished = var2;
+      this.willStartRecordingMetrics = true;
    }
 
-   public void startProfiling() {
-      this.delayProfilerStart = true;
+   public void stopRecordingMetrics() {
+      this.metricsRecorder = InactiveMetricsRecorder.INSTANCE;
    }
 
-   public ProfileResults finishProfiling() {
-      ProfileResults var1 = this.continousProfiler.getResults();
-      this.continousProfiler.disable();
-      return var1;
+   public void finishRecordingMetrics() {
+      this.metricsRecorder.end();
    }
 
    public Path getWorldPath(LevelResource var1) {
       return this.storageSource.getLevelPath(var1);
    }
@@ -1718,14 +1764,95 @@
 
    public RegistryAccess registryAccess() {
       return this.registryHolder;
    }
 
-   @Nullable
    public TextFilter createTextFilterForPlayer(ServerPlayer var1) {
+      return TextFilter.DUMMY;
+   }
+
+   public boolean isResourcePackRequired() {
+      return false;
+   }
+
+   public ServerPlayerGameMode createGameModeForPlayer(ServerPlayer var1) {
+      return (ServerPlayerGameMode)(this.isDemo() ? new DemoMode(var1) : new ServerPlayerGameMode(var1));
+   }
+
+   @Nullable
+   public GameType getForcedGameType() {
       return null;
    }
 
+   public ResourceManager getResourceManager() {
+      return this.resources.getResourceManager();
+   }
+
+   @Nullable
+   public Component getResourcePackPrompt() {
+      return null;
+   }
+
+   public boolean isTimeProfilerRunning() {
+      return this.debugCommandProfilerDelayStart || this.debugCommandProfiler != null;
+   }
+
+   public void startTimeProfiler() {
+      this.debugCommandProfilerDelayStart = true;
+   }
+
+   public ProfileResults stopTimeProfiler() {
+      if (this.debugCommandProfiler == null) {
+         return EmptyProfileResults.EMPTY;
+      } else {
+         ProfileResults var1 = this.debugCommandProfiler.stop(Util.getNanos(), this.tickCount);
+         this.debugCommandProfiler = null;
+         return var1;
+      }
+   }
+
    static {
       DEMO_SETTINGS = new LevelSettings("Demo World", GameType.SURVIVAL, false, Difficulty.NORMAL, false, new GameRules(), DataPackConfig.DEFAULT);
    }
+
+   private static class TimeProfiler {
+      final long startNanos;
+      final int startTick;
+
+      TimeProfiler(long var1, int var3) {
+         this.startNanos = var1;
+         this.startTick = var3;
+      }
+
+      ProfileResults stop(final long var1, final int var3) {
+         return new ProfileResults() {
+            public List<ResultField> getTimes(String var1x) {
+               return Collections.emptyList();
+            }
+
+            public boolean saveResults(Path var1x) {
+               return false;
+            }
+
+            public long getStartTimeNano() {
+               return TimeProfiler.this.startNanos;
+            }
+
+            public int getStartTimeTicks() {
+               return TimeProfiler.this.startTick;
+            }
+
+            public long getEndTimeNano() {
+               return var1;
+            }
+
+            public int getEndTimeTicks() {
+               return var3;
+            }
+
+            public String getProfilerResults() {
+               return "";
+            }
+         };
+      }
+   }
 }
