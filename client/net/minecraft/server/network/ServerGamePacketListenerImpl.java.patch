--- net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -5,21 +5,23 @@
 import com.google.common.primitives.Floats;
 import com.mojang.brigadier.ParseResults;
 import com.mojang.brigadier.StringReader;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GenericFutureListener;
-import it.unimi.dsi.fastutil.ints.Int2ShortMap;
-import it.unimi.dsi.fastutil.ints.Int2ShortOpenHashMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry;
+import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Optional;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.function.BiFunction;
 import java.util.function.Consumer;
+import java.util.function.UnaryOperator;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
 import net.minecraft.ChatFormatting;
 import net.minecraft.CrashReport;
@@ -29,11 +31,10 @@
 import net.minecraft.Util;
 import net.minecraft.advancements.Advancement;
 import net.minecraft.advancements.CriteriaTriggers;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
-import net.minecraft.core.NonNullList;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.ListTag;
 import net.minecraft.nbt.StringTag;
 import net.minecraft.network.Connection;
 import net.minecraft.network.chat.ChatType;
@@ -44,11 +45,10 @@
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.PacketUtils;
 import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundChatPacket;
 import net.minecraft.network.protocol.game.ClientboundCommandSuggestionsPacket;
-import net.minecraft.network.protocol.game.ClientboundContainerAckPacket;
 import net.minecraft.network.protocol.game.ClientboundContainerSetSlotPacket;
 import net.minecraft.network.protocol.game.ClientboundDisconnectPacket;
 import net.minecraft.network.protocol.game.ClientboundKeepAlivePacket;
 import net.minecraft.network.protocol.game.ClientboundMoveVehiclePacket;
 import net.minecraft.network.protocol.game.ClientboundPlayerPositionPacket;
@@ -60,11 +60,10 @@
 import net.minecraft.network.protocol.game.ServerboundChangeDifficultyPacket;
 import net.minecraft.network.protocol.game.ServerboundChatPacket;
 import net.minecraft.network.protocol.game.ServerboundClientCommandPacket;
 import net.minecraft.network.protocol.game.ServerboundClientInformationPacket;
 import net.minecraft.network.protocol.game.ServerboundCommandSuggestionPacket;
-import net.minecraft.network.protocol.game.ServerboundContainerAckPacket;
 import net.minecraft.network.protocol.game.ServerboundContainerButtonClickPacket;
 import net.minecraft.network.protocol.game.ServerboundContainerClickPacket;
 import net.minecraft.network.protocol.game.ServerboundContainerClosePacket;
 import net.minecraft.network.protocol.game.ServerboundCustomPayloadPacket;
 import net.minecraft.network.protocol.game.ServerboundEditBookPacket;
@@ -115,18 +114,18 @@
 import net.minecraft.world.entity.PlayerRideableJumping;
 import net.minecraft.world.entity.animal.horse.AbstractHorse;
 import net.minecraft.world.entity.item.ItemEntity;
 import net.minecraft.world.entity.player.ChatVisiblity;
 import net.minecraft.world.entity.player.Inventory;
+import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.entity.projectile.AbstractArrow;
 import net.minecraft.world.entity.vehicle.Boat;
 import net.minecraft.world.inventory.AbstractContainerMenu;
 import net.minecraft.world.inventory.AnvilMenu;
 import net.minecraft.world.inventory.BeaconMenu;
 import net.minecraft.world.inventory.MerchantMenu;
 import net.minecraft.world.inventory.RecipeBookMenu;
-import net.minecraft.world.inventory.Slot;
 import net.minecraft.world.item.BlockItem;
 import net.minecraft.world.item.BucketItem;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
@@ -153,35 +152,36 @@
 import net.minecraft.world.phys.shapes.VoxelShape;
 import org.apache.commons.lang3.StringUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
-public class ServerGamePacketListenerImpl implements ServerGamePacketListener {
+public class ServerGamePacketListenerImpl implements ServerPlayerConnection, ServerGamePacketListener {
    private static final Logger LOGGER = LogManager.getLogger();
    public final Connection connection;
    private final MinecraftServer server;
    public ServerPlayer player;
    private int tickCount;
    private long keepAliveTime;
    private boolean keepAlivePending;
    private long keepAliveChallenge;
    private int chatSpamTickCount;
    private int dropSpamTickCount;
-   private final Int2ShortMap expectedAcks = new Int2ShortOpenHashMap();
    private double firstGoodX;
    private double firstGoodY;
    private double firstGoodZ;
    private double lastGoodX;
    private double lastGoodY;
    private double lastGoodZ;
+   @Nullable
    private Entity lastVehicle;
    private double vehicleFirstGoodX;
    private double vehicleFirstGoodY;
    private double vehicleFirstGoodZ;
    private double vehicleLastGoodX;
    private double vehicleLastGoodY;
    private double vehicleLastGoodZ;
+   @Nullable
    private Vec3 awaitingPositionFromClient;
    private int awaitingTeleport;
    private int awaitingTeleportTime;
    private boolean clientIsFloating;
    private int aboveGroundTickCount;
@@ -194,15 +194,11 @@
       this.server = var1;
       this.connection = var2;
       var2.setListener(this);
       this.player = var3;
       var3.connection = this;
-      TextFilter var4 = var3.getTextFilter();
-      if (var4 != null) {
-         var4.join();
-      }
-
+      var3.getTextFilter().join();
    }
 
    public void tick() {
       this.resetPosition();
       this.player.xo = this.player.getX();
@@ -299,38 +295,28 @@
       this.connection.setReadOnly();
       Connection var10001 = this.connection;
       this.server.executeBlocking(var10001::handleDisconnection);
    }
 
-   private <T> void filterTextPacket(T var1, Consumer<T> var2, BiFunction<TextFilter, T, CompletableFuture<Optional<T>>> var3) {
+   private <T, R> void filterTextPacket(T var1, Consumer<R> var2, BiFunction<TextFilter, T, CompletableFuture<R>> var3) {
       MinecraftServer var4 = this.player.getLevel().getServer();
       Consumer var5 = (var2x) -> {
          if (this.getConnection().isConnected()) {
             var2.accept(var2x);
          } else {
             LOGGER.debug("Ignoring packet due to disconnection");
          }
 
       };
-      TextFilter var6 = this.player.getTextFilter();
-      if (var6 != null) {
-         ((CompletableFuture)var3.apply(var6, var1)).thenAcceptAsync((var1x) -> {
-            var1x.ifPresent(var5);
-         }, var4);
-      } else {
-         var4.execute(() -> {
-            var5.accept(var1);
-         });
-      }
-
+      ((CompletableFuture)var3.apply(this.player.getTextFilter(), var1)).thenAcceptAsync(var5, var4);
    }
 
-   private void filterTextPacket(String var1, Consumer<String> var2) {
+   private void filterTextPacket(String var1, Consumer<TextFilter.FilteredText> var2) {
       this.filterTextPacket(var1, var2, TextFilter::processStreamMessage);
    }
 
-   private void filterTextPacket(List<String> var1, Consumer<List<String>> var2) {
+   private void filterTextPacket(List<String> var1, Consumer<List<TextFilter.FilteredText>> var2) {
       this.filterTextPacket(var1, var2, TextFilter::processMessageBundle);
    }
 
    public void handlePlayerInput(ServerboundPlayerInputPacket var1) {
       PacketUtils.ensureRunningOnSameThread(var1, this, (ServerLevel)this.player.getLevel());
@@ -490,29 +476,32 @@
 
          String var6 = var1.getCommand();
          boolean var7 = var1.isTrackOutput();
          if (var2 != null) {
             CommandBlockEntity.Mode var8 = var3.getMode();
-            Direction var9 = (Direction)this.player.level.getBlockState(var4).getValue(CommandBlock.FACING);
-            BlockState var10;
+            BlockState var9 = this.player.level.getBlockState(var4);
+            Direction var10 = (Direction)var9.getValue(CommandBlock.FACING);
+            BlockState var11;
             switch(var1.getMode()) {
             case SEQUENCE:
-               var10 = Blocks.CHAIN_COMMAND_BLOCK.defaultBlockState();
-               this.player.level.setBlock(var4, (BlockState)((BlockState)var10.setValue(CommandBlock.FACING, var9)).setValue(CommandBlock.CONDITIONAL, var1.isConditional()), 2);
+               var11 = Blocks.CHAIN_COMMAND_BLOCK.defaultBlockState();
                break;
             case AUTO:
-               var10 = Blocks.REPEATING_COMMAND_BLOCK.defaultBlockState();
-               this.player.level.setBlock(var4, (BlockState)((BlockState)var10.setValue(CommandBlock.FACING, var9)).setValue(CommandBlock.CONDITIONAL, var1.isConditional()), 2);
+               var11 = Blocks.REPEATING_COMMAND_BLOCK.defaultBlockState();
                break;
             case REDSTONE:
             default:
-               var10 = Blocks.COMMAND_BLOCK.defaultBlockState();
-               this.player.level.setBlock(var4, (BlockState)((BlockState)var10.setValue(CommandBlock.FACING, var9)).setValue(CommandBlock.CONDITIONAL, var1.isConditional()), 2);
+               var11 = Blocks.COMMAND_BLOCK.defaultBlockState();
             }
 
-            var5.clearRemoved();
-            this.player.level.setBlockEntity(var4, var5);
+            BlockState var12 = (BlockState)((BlockState)var11.setValue(CommandBlock.FACING, var10)).setValue(CommandBlock.CONDITIONAL, var1.isConditional());
+            if (var12 != var9) {
+               this.player.level.setBlock(var4, var12, 2);
+               var5.setBlockState(var12);
+               this.player.level.getChunkAt(var4).setBlockEntity(var5);
+            }
+
             var2.setCommand(var6);
             var2.setTrackOutput(var7);
             if (!var7) {
                var2.setLastOutput((Component)null);
             }
@@ -553,14 +542,14 @@
       }
    }
 
    public void handlePickItem(ServerboundPickItemPacket var1) {
       PacketUtils.ensureRunningOnSameThread(var1, this, (ServerLevel)this.player.getLevel());
-      this.player.inventory.pickSlot(var1.getSlot());
-      this.player.connection.send(new ClientboundContainerSetSlotPacket(-2, this.player.inventory.selected, this.player.inventory.getItem(this.player.inventory.selected)));
-      this.player.connection.send(new ClientboundContainerSetSlotPacket(-2, var1.getSlot(), this.player.inventory.getItem(var1.getSlot())));
-      this.player.connection.send(new ClientboundSetCarriedItemPacket(this.player.inventory.selected));
+      this.player.getInventory().pickSlot(var1.getSlot());
+      this.player.connection.send(new ClientboundContainerSetSlotPacket(-2, this.player.getInventory().selected, this.player.getInventory().getItem(this.player.getInventory().selected)));
+      this.player.connection.send(new ClientboundContainerSetSlotPacket(-2, var1.getSlot(), this.player.getInventory().getItem(var1.getSlot())));
+      this.player.connection.send(new ClientboundSetCarriedItemPacket(this.player.getInventory().selected));
    }
 
    public void handleRenameItem(ServerboundRenameItemPacket var1) {
       PacketUtils.ensureRunningOnSameThread(var1, this, (ServerLevel)this.player.getLevel());
       if (this.player.containerMenu instanceof AnvilMenu) {
@@ -679,72 +668,95 @@
       }
 
    }
 
    public void handleEditBook(ServerboundEditBookPacket var1) {
-      ItemStack var2 = var1.getBook();
-      if (var2.getItem() == Items.WRITABLE_BOOK) {
-         CompoundTag var3 = var2.getTag();
-         if (WritableBookItem.makeSureTagIsValid(var3)) {
-            ArrayList var4 = Lists.newArrayList();
-            boolean var5 = var1.isSigning();
-            if (var5) {
-               var4.add(var3.getString("title"));
-            }
+      int var2 = var1.getSlot();
+      if (Inventory.isHotbarSlot(var2) || var2 == 40) {
+         ItemStack var3 = var1.getBook();
+         if (var3.is(Items.WRITABLE_BOOK)) {
+            CompoundTag var4 = var3.getTag();
+            if (WritableBookItem.makeSureTagIsValid(var4)) {
+               ArrayList var5 = Lists.newArrayList();
+               boolean var6 = var1.isSigning();
+               if (var6) {
+                  var5.add(var4.getString("title"));
+               }
 
-            ListTag var6 = var3.getList("pages", 8);
+               ListTag var7 = var4.getList("pages", 8);
 
-            int var7;
-            for(var7 = 0; var7 < var6.size(); ++var7) {
-               var4.add(var6.getString(var7));
-            }
+               for(int var8 = 0; var8 < var7.size(); ++var8) {
+                  var5.add(var7.getString(var8));
+               }
 
-            var7 = var1.getSlot();
-            if (Inventory.isHotbarSlot(var7) || var7 == 40) {
-               this.filterTextPacket((List)var4, var5 ? (var2x) -> {
-                  this.signBook((String)var2x.get(0), var2x.subList(1, var2x.size()), var7);
+               this.filterTextPacket((List)var5, var6 ? (var2x) -> {
+                  this.signBook((TextFilter.FilteredText)var2x.get(0), var2x.subList(1, var2x.size()), var2);
                } : (var2x) -> {
-                  this.updateBookContents(var2x, var7);
+                  this.updateBookContents(var2x, var2);
                });
             }
          }
       }
    }
 
-   private void updateBookContents(List<String> var1, int var2) {
-      ItemStack var3 = this.player.inventory.getItem(var2);
-      if (var3.getItem() == Items.WRITABLE_BOOK) {
-         ListTag var4 = new ListTag();
-         var1.stream().map(StringTag::valueOf).forEach(var4::add);
-         var3.addTagElement("pages", var4);
+   private void updateBookContents(List<TextFilter.FilteredText> var1, int var2) {
+      ItemStack var3 = this.player.getInventory().getItem(var2);
+      if (var3.is(Items.WRITABLE_BOOK)) {
+         this.updateBookPages(var1, UnaryOperator.identity(), var3);
       }
    }
 
-   private void signBook(String var1, List<String> var2, int var3) {
-      ItemStack var4 = this.player.inventory.getItem(var3);
-      if (var4.getItem() == Items.WRITABLE_BOOK) {
+   private void signBook(TextFilter.FilteredText var1, List<TextFilter.FilteredText> var2, int var3) {
+      ItemStack var4 = this.player.getInventory().getItem(var3);
+      if (var4.is(Items.WRITABLE_BOOK)) {
          ItemStack var5 = new ItemStack(Items.WRITTEN_BOOK);
          CompoundTag var6 = var4.getTag();
          if (var6 != null) {
             var5.setTag(var6.copy());
          }
 
          var5.addTagElement("author", StringTag.valueOf(this.player.getName().getString()));
-         var5.addTagElement("title", StringTag.valueOf(var1));
-         ListTag var7 = new ListTag();
-         Iterator var8 = var2.iterator();
+         if (this.player.isTextFilteringEnabled()) {
+            var5.addTagElement("title", StringTag.valueOf(var1.getFiltered()));
+         } else {
+            var5.addTagElement("filtered_title", StringTag.valueOf(var1.getFiltered()));
+            var5.addTagElement("title", StringTag.valueOf(var1.getRaw()));
+         }
 
-         while(var8.hasNext()) {
-            String var9 = (String)var8.next();
-            TextComponent var10 = new TextComponent(var9);
-            String var11 = Component.Serializer.toJson(var10);
-            var7.add(StringTag.valueOf(var11));
+         this.updateBookPages(var2, (var0) -> {
+            return Component.Serializer.toJson(new TextComponent(var0));
+         }, var5);
+         this.player.getInventory().setItem(var3, var5);
+      }
+   }
+
+   private void updateBookPages(List<TextFilter.FilteredText> var1, UnaryOperator<String> var2, ItemStack var3) {
+      ListTag var4 = new ListTag();
+      if (this.player.isTextFilteringEnabled()) {
+         var1.stream().map((var1x) -> {
+            return StringTag.valueOf((String)var2.apply(var1x.getFiltered()));
+         }).forEach(var4::add);
+      } else {
+         CompoundTag var5 = new CompoundTag();
+         int var6 = 0;
+
+         for(int var7 = var1.size(); var6 < var7; ++var6) {
+            TextFilter.FilteredText var8 = (TextFilter.FilteredText)var1.get(var6);
+            String var9 = var8.getRaw();
+            var4.add(StringTag.valueOf((String)var2.apply(var9)));
+            String var10 = var8.getFiltered();
+            if (!var9.equals(var10)) {
+               var5.putString(String.valueOf(var6), (String)var2.apply(var10));
+            }
          }
 
-         var5.addTagElement("pages", var7);
-         this.player.inventory.setItem(var3, var5);
+         if (!var5.isEmpty()) {
+            var3.addTagElement("filtered_pages", var5);
+         }
       }
+
+      var3.addTagElement("pages", var4);
    }
 
    public void handleEntityTagQuery(ServerboundEntityTagQuery var1) {
       PacketUtils.ensureRunningOnSameThread(var1, this, (ServerLevel)this.player.getLevel());
       if (this.player.hasPermissions(2)) {
@@ -850,11 +862,11 @@
                         LOGGER.warn("{} moved wrongly!", this.player.getName().getString());
                      }
 
                      this.player.absMoveTo(var11, var13, var15, var17, var18);
                      if (this.player.noPhysics || this.player.isSleeping() || (!var34 || !var2.noCollision(this.player, var35)) && !this.isPlayerCollidingWithAnythingNew(var2, var35)) {
-                        this.clientIsFloating = var32 >= -0.03125D && this.player.gameMode.getGameModeForPlayer() != GameType.SPECTATOR && !this.server.isFlightAllowed() && !this.player.abilities.mayfly && !this.player.hasEffect(MobEffects.LEVITATION) && !this.player.isFallFlying() && this.noBlocksAround(this.player);
+                        this.clientIsFloating = var32 >= -0.03125D && this.player.gameMode.getGameModeForPlayer() != GameType.SPECTATOR && !this.server.isFlightAllowed() && !this.player.getAbilities().mayfly && !this.player.hasEffect(MobEffects.LEVITATION) && !this.player.isFallFlying() && this.noBlocksAround(this.player);
                         this.player.getLevel().getChunkSource().move(this.player);
                         this.player.doCheckFallDamage(this.player.getY() - var9, var1.isOnGround());
                         this.player.setOnGround(var1.isOnGround());
                         if (var31) {
                            this.player.fallDistance = 0.0F;
@@ -882,28 +894,36 @@
       return var3.anyMatch((var1x) -> {
          return !Shapes.joinIsNotEmpty(var1x, var4, BooleanOp.AND);
       });
    }
 
+   public void dismount(double var1, double var3, double var5, float var7, float var8) {
+      this.teleport(var1, var3, var5, var7, var8, Collections.emptySet(), true);
+   }
+
    public void teleport(double var1, double var3, double var5, float var7, float var8) {
-      this.teleport(var1, var3, var5, var7, var8, Collections.emptySet());
+      this.teleport(var1, var3, var5, var7, var8, Collections.emptySet(), false);
    }
 
    public void teleport(double var1, double var3, double var5, float var7, float var8, Set<ClientboundPlayerPositionPacket.RelativeArgument> var9) {
-      double var10 = var9.contains(ClientboundPlayerPositionPacket.RelativeArgument.X) ? this.player.getX() : 0.0D;
-      double var12 = var9.contains(ClientboundPlayerPositionPacket.RelativeArgument.Y) ? this.player.getY() : 0.0D;
-      double var14 = var9.contains(ClientboundPlayerPositionPacket.RelativeArgument.Z) ? this.player.getZ() : 0.0D;
-      float var16 = var9.contains(ClientboundPlayerPositionPacket.RelativeArgument.Y_ROT) ? this.player.yRot : 0.0F;
-      float var17 = var9.contains(ClientboundPlayerPositionPacket.RelativeArgument.X_ROT) ? this.player.xRot : 0.0F;
+      this.teleport(var1, var3, var5, var7, var8, var9, false);
+   }
+
+   public void teleport(double var1, double var3, double var5, float var7, float var8, Set<ClientboundPlayerPositionPacket.RelativeArgument> var9, boolean var10) {
+      double var11 = var9.contains(ClientboundPlayerPositionPacket.RelativeArgument.X) ? this.player.getX() : 0.0D;
+      double var13 = var9.contains(ClientboundPlayerPositionPacket.RelativeArgument.Y) ? this.player.getY() : 0.0D;
+      double var15 = var9.contains(ClientboundPlayerPositionPacket.RelativeArgument.Z) ? this.player.getZ() : 0.0D;
+      float var17 = var9.contains(ClientboundPlayerPositionPacket.RelativeArgument.Y_ROT) ? this.player.yRot : 0.0F;
+      float var18 = var9.contains(ClientboundPlayerPositionPacket.RelativeArgument.X_ROT) ? this.player.xRot : 0.0F;
       this.awaitingPositionFromClient = new Vec3(var1, var3, var5);
       if (++this.awaitingTeleport == Integer.MAX_VALUE) {
          this.awaitingTeleport = 0;
       }
 
       this.awaitingTeleportTime = this.tickCount;
       this.player.absMoveTo(var1, var3, var5, var7, var8);
-      this.player.connection.send(new ClientboundPlayerPositionPacket(var1 - var10, var3 - var12, var5 - var14, var7 - var16, var8 - var17, var9, this.awaitingTeleport));
+      this.player.connection.send(new ClientboundPlayerPositionPacket(var1 - var11, var3 - var13, var5 - var15, var7 - var17, var8 - var18, var9, this.awaitingTeleport, var10));
    }
 
    public void handlePlayerAction(ServerboundPlayerActionPacket var1) {
       PacketUtils.ensureRunningOnSameThread(var1, this, (ServerLevel)this.player.getLevel());
       BlockPos var2 = var1.getPos();
@@ -935,11 +955,11 @@
          this.player.releaseUsingItem();
          return;
       case START_DESTROY_BLOCK:
       case ABORT_DESTROY_BLOCK:
       case STOP_DESTROY_BLOCK:
-         this.player.gameMode.handleBlockBreakAction(var2, var3, var1.getDirection(), this.server.getMaxBuildHeight());
+         this.player.gameMode.handleBlockBreakAction(var2, var3, var1.getDirection(), this.player.level.getMaxBuildHeight());
          return;
       default:
          throw new IllegalArgumentException("Invalid player action");
       }
    }
@@ -960,23 +980,24 @@
       ItemStack var4 = this.player.getItemInHand(var3);
       BlockHitResult var5 = var1.getHitResult();
       BlockPos var6 = var5.getBlockPos();
       Direction var7 = var5.getDirection();
       this.player.resetLastActionTime();
-      if (var6.getY() < this.server.getMaxBuildHeight()) {
+      int var8 = this.player.level.getMaxBuildHeight();
+      if (var6.getY() < var8) {
          if (this.awaitingPositionFromClient == null && this.player.distanceToSqr((double)var6.getX() + 0.5D, (double)var6.getY() + 0.5D, (double)var6.getZ() + 0.5D) < 64.0D && var2.mayInteract(this.player, var6)) {
-            InteractionResult var8 = this.player.gameMode.useItemOn(this.player, var2, var4, var3, var5);
-            if (var7 == Direction.UP && !var8.consumesAction() && var6.getY() >= this.server.getMaxBuildHeight() - 1 && wasBlockPlacementAttempt(this.player, var4)) {
-               MutableComponent var9 = (new TranslatableComponent("build.tooHigh", new Object[]{this.server.getMaxBuildHeight()})).withStyle(ChatFormatting.RED);
-               this.player.connection.send(new ClientboundChatPacket(var9, ChatType.GAME_INFO, Util.NIL_UUID));
-            } else if (var8.shouldSwing()) {
+            InteractionResult var9 = this.player.gameMode.useItemOn(this.player, var2, var4, var3, var5);
+            if (var7 == Direction.UP && !var9.consumesAction() && var6.getY() >= var8 - 1 && wasBlockPlacementAttempt(this.player, var4)) {
+               MutableComponent var10 = (new TranslatableComponent("build.tooHigh", new Object[]{var8})).withStyle(ChatFormatting.RED);
+               this.player.sendMessage(var10, ChatType.GAME_INFO, Util.NIL_UUID);
+            } else if (var9.shouldSwing()) {
                this.player.swing(var3, true);
             }
          }
       } else {
-         MutableComponent var10 = (new TranslatableComponent("build.tooHigh", new Object[]{this.server.getMaxBuildHeight()})).withStyle(ChatFormatting.RED);
-         this.player.connection.send(new ClientboundChatPacket(var10, ChatType.GAME_INFO, Util.NIL_UUID));
+         MutableComponent var11 = (new TranslatableComponent("build.tooHigh", new Object[]{var8})).withStyle(ChatFormatting.RED);
+         this.player.sendMessage(var11, ChatType.GAME_INFO, Util.NIL_UUID);
       }
 
       this.player.connection.send(new ClientboundBlockUpdatePacket(var2, var6));
       this.player.connection.send(new ClientboundBlockUpdatePacket(var2, var6.relative(var7)));
    }
@@ -1012,10 +1033,16 @@
       }
 
    }
 
    public void handleResourcePackResponse(ServerboundResourcePackPacket var1) {
+      PacketUtils.ensureRunningOnSameThread(var1, this, (ServerLevel)this.player.getLevel());
+      if (var1.getAction() == ServerboundResourcePackPacket.Action.DECLINED && this.server.isResourcePackRequired()) {
+         LOGGER.info("Disconnecting {} due to resource pack rejection", this.player.getName());
+         this.disconnect(new TranslatableComponent("multiplayer.requiredTexturePrompt.disconnect"));
+      }
+
    }
 
    public void handlePaddleBoat(ServerboundPaddleBoatPacket var1) {
       PacketUtils.ensureRunningOnSameThread(var1, this, (ServerLevel)this.player.getLevel());
       Entity var2 = this.player.getVehicle();
@@ -1029,15 +1056,11 @@
       LOGGER.info("{} lost connection: {}", this.player.getName().getString(), var1.getString());
       this.server.invalidateStatus();
       this.server.getPlayerList().broadcastMessage((new TranslatableComponent("multiplayer.player.left", new Object[]{this.player.getDisplayName()})).withStyle(ChatFormatting.YELLOW), ChatType.SYSTEM, Util.NIL_UUID);
       this.player.disconnect();
       this.server.getPlayerList().remove(this.player);
-      TextFilter var2 = this.player.getTextFilter();
-      if (var2 != null) {
-         var2.leave();
-      }
-
+      this.player.getTextFilter().leave();
       if (this.isSingleplayerOwner()) {
          LOGGER.info("Stopping singleplayer server as player logged out");
          this.server.halt(false);
       }
 
@@ -1046,77 +1069,70 @@
    public void send(Packet<?> var1) {
       this.send(var1, (GenericFutureListener)null);
    }
 
    public void send(Packet<?> var1, @Nullable GenericFutureListener<? extends Future<? super Void>> var2) {
-      if (var1 instanceof ClientboundChatPacket) {
-         ClientboundChatPacket var3 = (ClientboundChatPacket)var1;
-         ChatVisiblity var4 = this.player.getChatVisibility();
-         if (var4 == ChatVisiblity.HIDDEN && var3.getType() != ChatType.GAME_INFO) {
-            return;
-         }
-
-         if (var4 == ChatVisiblity.SYSTEM && !var3.isSystem()) {
-            return;
-         }
-      }
-
       try {
          this.connection.send(var1, var2);
       } catch (Throwable var6) {
-         CrashReport var7 = CrashReport.forThrowable(var6, "Sending packet");
-         CrashReportCategory var5 = var7.addCategory("Packet being sent");
+         CrashReport var4 = CrashReport.forThrowable(var6, "Sending packet");
+         CrashReportCategory var5 = var4.addCategory("Packet being sent");
          var5.setDetail("Packet class", () -> {
             return var1.getClass().getCanonicalName();
          });
-         throw new ReportedException(var7);
+         throw new ReportedException(var4);
       }
    }
 
    public void handleSetCarriedItem(ServerboundSetCarriedItemPacket var1) {
       PacketUtils.ensureRunningOnSameThread(var1, this, (ServerLevel)this.player.getLevel());
       if (var1.getSlot() >= 0 && var1.getSlot() < Inventory.getSelectionSize()) {
-         if (this.player.inventory.selected != var1.getSlot() && this.player.getUsedItemHand() == InteractionHand.MAIN_HAND) {
+         if (this.player.getInventory().selected != var1.getSlot() && this.player.getUsedItemHand() == InteractionHand.MAIN_HAND) {
             this.player.stopUsingItem();
          }
 
-         this.player.inventory.selected = var1.getSlot();
+         this.player.getInventory().selected = var1.getSlot();
          this.player.resetLastActionTime();
       } else {
          LOGGER.warn("{} tried to set an invalid carried item", this.player.getName().getString());
       }
    }
 
    public void handleChat(ServerboundChatPacket var1) {
       String var2 = StringUtils.normalizeSpace(var1.getMessage());
+
+      for(int var3 = 0; var3 < var2.length(); ++var3) {
+         if (!SharedConstants.isAllowedChatCharacter(var2.charAt(var3))) {
+            this.disconnect(new TranslatableComponent("multiplayer.disconnect.illegal_characters"));
+            return;
+         }
+      }
+
       if (var2.startsWith("/")) {
          PacketUtils.ensureRunningOnSameThread(var1, this, (ServerLevel)this.player.getLevel());
-         this.handleChat(var2);
+         this.handleChat(TextFilter.FilteredText.passThrough(var2));
       } else {
          this.filterTextPacket(var2, this::handleChat);
       }
 
    }
 
-   private void handleChat(String var1) {
+   private void handleChat(TextFilter.FilteredText var1) {
       if (this.player.getChatVisibility() == ChatVisiblity.HIDDEN) {
-         this.send(new ClientboundChatPacket((new TranslatableComponent("chat.cannotSend")).withStyle(ChatFormatting.RED), ChatType.SYSTEM, Util.NIL_UUID));
+         this.send(new ClientboundChatPacket((new TranslatableComponent("chat.disabled.options")).withStyle(ChatFormatting.RED), ChatType.SYSTEM, Util.NIL_UUID));
       } else {
          this.player.resetLastActionTime();
-
-         for(int var2 = 0; var2 < var1.length(); ++var2) {
-            if (!SharedConstants.isAllowedChatCharacter(var1.charAt(var2))) {
-               this.disconnect(new TranslatableComponent("multiplayer.disconnect.illegal_characters"));
-               return;
-            }
-         }
-
-         if (var1.startsWith("/")) {
-            this.handleCommand(var1);
+         String var2 = var1.getRaw();
+         if (var2.startsWith("/")) {
+            this.handleCommand(var2);
          } else {
-            TranslatableComponent var3 = new TranslatableComponent("chat.type.text", new Object[]{this.player.getDisplayName(), var1});
-            this.server.getPlayerList().broadcastMessage(var3, ChatType.CHAT, this.player.getUUID());
+            String var3 = var1.getFiltered();
+            TranslatableComponent var4 = var3.isEmpty() ? null : new TranslatableComponent("chat.type.text", new Object[]{this.player.getDisplayName(), var3});
+            TranslatableComponent var5 = new TranslatableComponent("chat.type.text", new Object[]{this.player.getDisplayName(), var2});
+            this.server.getPlayerList().broadcastMessage(var5, (var3x) -> {
+               return this.player.shouldFilterMessageTo(var3x) ? var4 : var5;
+            }, ChatType.CHAT, this.player.getUUID());
          }
 
          this.chatSpamTickCount += 20;
          if (this.chatSpamTickCount > 200 && !this.server.getPlayerList().isOp(this.player.getGameProfile())) {
             this.disconnect(new TranslatableComponent("disconnect.spam"));
@@ -1190,39 +1206,48 @@
    }
 
    public void handleInteract(ServerboundInteractPacket var1) {
       PacketUtils.ensureRunningOnSameThread(var1, this, (ServerLevel)this.player.getLevel());
       ServerLevel var2 = this.player.getLevel();
-      Entity var3 = var1.getTarget(var2);
+      final Entity var3 = var1.getTarget(var2);
       this.player.resetLastActionTime();
       this.player.setShiftKeyDown(var1.isUsingSecondaryAction());
       if (var3 != null) {
          double var4 = 36.0D;
          if (this.player.distanceToSqr(var3) < 36.0D) {
-            InteractionHand var6 = var1.getHand();
-            ItemStack var7 = var6 != null ? this.player.getItemInHand(var6).copy() : ItemStack.EMPTY;
-            Optional var8 = Optional.empty();
-            if (var1.getAction() == ServerboundInteractPacket.Action.INTERACT) {
-               var8 = Optional.of(this.player.interactOn(var3, var6));
-            } else if (var1.getAction() == ServerboundInteractPacket.Action.INTERACT_AT) {
-               var8 = Optional.of(var3.interactAt(this.player, var1.getLocation(), var6));
-            } else if (var1.getAction() == ServerboundInteractPacket.Action.ATTACK) {
-               if (var3 instanceof ItemEntity || var3 instanceof ExperienceOrb || var3 instanceof AbstractArrow || var3 == this.player) {
-                  this.disconnect(new TranslatableComponent("multiplayer.disconnect.invalid_entity_attacked"));
-                  LOGGER.warn("Player {} tried to attack an invalid entity", this.player.getName().getString());
-                  return;
+            var1.dispatch(new ServerboundInteractPacket.Handler() {
+               private void performInteraction(InteractionHand var1, ServerGamePacketListenerImpl.EntityInteraction var2) {
+                  ItemStack var3x = ServerGamePacketListenerImpl.this.player.getItemInHand(var1).copy();
+                  InteractionResult var4 = var2.run(ServerGamePacketListenerImpl.this.player, var3, var1);
+                  if (var4.consumesAction()) {
+                     CriteriaTriggers.PLAYER_INTERACTED_WITH_ENTITY.trigger(ServerGamePacketListenerImpl.this.player, var3x, var3);
+                     if (var4.shouldSwing()) {
+                        ServerGamePacketListenerImpl.this.player.swing(var1, true);
+                     }
+                  }
+
                }
 
-               this.player.attack(var3);
-            }
+               public void onInteraction(InteractionHand var1) {
+                  this.performInteraction(var1, Player::interactOn);
+               }
 
-            if (var8.isPresent() && ((InteractionResult)var8.get()).consumesAction()) {
-               CriteriaTriggers.PLAYER_INTERACTED_WITH_ENTITY.trigger(this.player, var7, var3);
-               if (((InteractionResult)var8.get()).shouldSwing()) {
-                  this.player.swing(var6, true);
+               public void onInteraction(InteractionHand var1, Vec3 var2) {
+                  this.performInteraction(var1, (var1x, var2x, var3x) -> {
+                     return var2x.interactAt(var1x, var2, var3x);
+                  });
                }
-            }
+
+               public void onAttack() {
+                  if (!(var3 instanceof ItemEntity) && !(var3 instanceof ExperienceOrb) && !(var3 instanceof AbstractArrow) && var3 != ServerGamePacketListenerImpl.this.player) {
+                     ServerGamePacketListenerImpl.this.player.attack(var3);
+                  } else {
+                     ServerGamePacketListenerImpl.this.disconnect(new TranslatableComponent("multiplayer.disconnect.invalid_entity_attacked"));
+                     ServerGamePacketListenerImpl.LOGGER.warn("Player {} tried to attack an invalid entity", ServerGamePacketListenerImpl.this.player.getName().getString());
+                  }
+               }
+            });
          }
       }
 
    }
 
@@ -1260,59 +1285,45 @@
    }
 
    public void handleContainerClick(ServerboundContainerClickPacket var1) {
       PacketUtils.ensureRunningOnSameThread(var1, this, (ServerLevel)this.player.getLevel());
       this.player.resetLastActionTime();
-      if (this.player.containerMenu.containerId == var1.getContainerId() && this.player.containerMenu.isSynched(this.player)) {
+      if (this.player.containerMenu.containerId == var1.getContainerId()) {
          if (this.player.isSpectator()) {
-            NonNullList var2 = NonNullList.create();
-
-            for(int var3 = 0; var3 < this.player.containerMenu.slots.size(); ++var3) {
-               var2.add(((Slot)this.player.containerMenu.slots.get(var3)).getItem());
-            }
-
-            this.player.refreshContainer(this.player.containerMenu, var2);
+            this.player.containerMenu.sendAllDataToRemote();
          } else {
-            ItemStack var6 = this.player.containerMenu.clicked(var1.getSlotNum(), var1.getButtonNum(), var1.getClickType(), this.player);
-            if (ItemStack.matches(var1.getItem(), var6)) {
-               this.player.connection.send(new ClientboundContainerAckPacket(var1.getContainerId(), var1.getUid(), true));
-               this.player.ignoreSlotUpdateHack = true;
-               this.player.containerMenu.broadcastChanges();
-               this.player.broadcastCarriedItem();
-               this.player.ignoreSlotUpdateHack = false;
-            } else {
-               this.expectedAcks.put(this.player.containerMenu.containerId, var1.getUid());
-               this.player.connection.send(new ClientboundContainerAckPacket(var1.getContainerId(), var1.getUid(), false));
-               this.player.containerMenu.setSynched(this.player, false);
-               NonNullList var7 = NonNullList.create();
+            this.player.containerMenu.suppressRemoteUpdates();
+            this.player.containerMenu.clicked(var1.getSlotNum(), var1.getButtonNum(), var1.getClickType(), this.player);
+            ObjectIterator var2 = Int2ObjectMaps.fastIterable(var1.getChangedSlots()).iterator();
 
-               for(int var4 = 0; var4 < this.player.containerMenu.slots.size(); ++var4) {
-                  ItemStack var5 = ((Slot)this.player.containerMenu.slots.get(var4)).getItem();
-                  var7.add(var5.isEmpty() ? ItemStack.EMPTY : var5);
-               }
-
-               this.player.refreshContainer(this.player.containerMenu, var7);
+            while(var2.hasNext()) {
+               Entry var3 = (Entry)var2.next();
+               this.player.containerMenu.setRemoteSlot(var3.getIntKey(), (ItemStack)var3.getValue());
             }
+
+            this.player.containerMenu.setRemoteCarried(var1.getCarriedItem());
+            this.player.containerMenu.resumeRemoteUpdates();
+            this.player.containerMenu.broadcastChanges();
          }
       }
 
    }
 
    public void handlePlaceRecipe(ServerboundPlaceRecipePacket var1) {
       PacketUtils.ensureRunningOnSameThread(var1, this, (ServerLevel)this.player.getLevel());
       this.player.resetLastActionTime();
-      if (!this.player.isSpectator() && this.player.containerMenu.containerId == var1.getContainerId() && this.player.containerMenu.isSynched(this.player) && this.player.containerMenu instanceof RecipeBookMenu) {
+      if (!this.player.isSpectator() && this.player.containerMenu.containerId == var1.getContainerId() && this.player.containerMenu instanceof RecipeBookMenu) {
          this.server.getRecipeManager().byKey(var1.getRecipe()).ifPresent((var2) -> {
             ((RecipeBookMenu)this.player.containerMenu).handlePlacement(var1.isShiftDown(), var2, this.player);
          });
       }
    }
 
    public void handleContainerButtonClick(ServerboundContainerButtonClickPacket var1) {
       PacketUtils.ensureRunningOnSameThread(var1, this, (ServerLevel)this.player.getLevel());
       this.player.resetLastActionTime();
-      if (this.player.containerMenu.containerId == var1.getContainerId() && this.player.containerMenu.isSynched(this.player) && !this.player.isSpectator()) {
+      if (this.player.containerMenu.containerId == var1.getContainerId() && !this.player.isSpectator()) {
          this.player.containerMenu.clickMenuButton(this.player, var1.getButtonId());
          this.player.containerMenu.broadcastChanges();
       }
 
    }
@@ -1342,37 +1353,27 @@
                this.player.inventoryMenu.setItem(var1.getSlotNum(), ItemStack.EMPTY);
             } else {
                this.player.inventoryMenu.setItem(var1.getSlotNum(), var3);
             }
 
-            this.player.inventoryMenu.setSynched(this.player, true);
             this.player.inventoryMenu.broadcastChanges();
          } else if (var2 && var9 && this.dropSpamTickCount < 200) {
             this.dropSpamTickCount += 20;
             this.player.drop(var3, true);
          }
       }
 
    }
 
-   public void handleContainerAck(ServerboundContainerAckPacket var1) {
-      PacketUtils.ensureRunningOnSameThread(var1, this, (ServerLevel)this.player.getLevel());
-      int var2 = this.player.containerMenu.containerId;
-      if (var2 == var1.getContainerId() && this.expectedAcks.getOrDefault(var2, (short)(var1.getUid() + 1)) == var1.getUid() && !this.player.containerMenu.isSynched(this.player) && !this.player.isSpectator()) {
-         this.player.containerMenu.setSynched(this.player, true);
-      }
-
-   }
-
    public void handleSignUpdate(ServerboundSignUpdatePacket var1) {
       List var2 = (List)Stream.of(var1.getLines()).map(ChatFormatting::stripFormatting).collect(Collectors.toList());
       this.filterTextPacket(var2, (var2x) -> {
          this.updateSignText(var1, var2x);
       });
    }
 
-   private void updateSignText(ServerboundSignUpdatePacket var1, List<String> var2) {
+   private void updateSignText(ServerboundSignUpdatePacket var1, List<TextFilter.FilteredText> var2) {
       this.player.resetLastActionTime();
       ServerLevel var3 = this.player.getLevel();
       BlockPos var4 = var1.getPos();
       if (var3.hasChunkAt(var4)) {
          BlockState var5 = var3.getBlockState(var4);
@@ -1386,11 +1387,16 @@
             LOGGER.warn("Player {} just tried to change non-editable sign", this.player.getName().getString());
             return;
          }
 
          for(int var8 = 0; var8 < var2.size(); ++var8) {
-            var7.setMessage(var8, new TextComponent((String)var2.get(var8)));
+            TextFilter.FilteredText var9 = (TextFilter.FilteredText)var2.get(var8);
+            if (this.player.isTextFilteringEnabled()) {
+               var7.setMessage(var8, new TextComponent(var9.getFiltered()));
+            } else {
+               var7.setMessage(var8, new TextComponent(var9.getRaw()), new TextComponent(var9.getFiltered()));
+            }
          }
 
          var7.setChanged();
          var3.sendBlockUpdated(var4, var5, var5, 3);
       }
@@ -1408,11 +1414,11 @@
 
    }
 
    public void handlePlayerAbilities(ServerboundPlayerAbilitiesPacket var1) {
       PacketUtils.ensureRunningOnSameThread(var1, this, (ServerLevel)this.player.getLevel());
-      this.player.abilities.flying = var1.isFlying() && this.player.abilities.mayfly;
+      this.player.getAbilities().flying = var1.isFlying() && this.player.getAbilities().mayfly;
    }
 
    public void handleClientInformation(ServerboundClientInformationPacket var1) {
       PacketUtils.ensureRunningOnSameThread(var1, this, (ServerLevel)this.player.getLevel());
       this.player.updateOptions(var1);
@@ -1432,6 +1438,15 @@
       PacketUtils.ensureRunningOnSameThread(var1, this, (ServerLevel)this.player.getLevel());
       if (this.player.hasPermissions(2) || this.isSingleplayerOwner()) {
          this.server.setDifficultyLocked(var1.isLocked());
       }
    }
+
+   public ServerPlayer getPlayer() {
+      return this.player;
+   }
+
+   @FunctionalInterface
+   interface EntityInteraction {
+      InteractionResult run(ServerPlayer var1, Entity var2, InteractionHand var3);
+   }
 }
