--- net/minecraft/world/level/chunk/LevelChunk.java
+++ net/minecraft/world/level/chunk/LevelChunk.java
@@ -1,84 +1,97 @@
 package net.minecraft.world.level.chunk;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
+import com.google.common.collect.UnmodifiableIterator;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.shorts.ShortList;
 import it.unimi.dsi.fastutil.shorts.ShortListIterator;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Iterator;
-import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.Map.Entry;
 import java.util.function.Consumer;
-import java.util.function.Predicate;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 import javax.annotation.Nullable;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportedException;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Registry;
+import net.minecraft.core.SectionPos;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.server.level.ChunkHolder;
 import net.minecraft.server.level.ServerLevel;
-import net.minecraft.util.ClassInstanceMultiMap;
-import net.minecraft.util.Mth;
+import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.EntityType;
-import net.minecraft.world.entity.boss.EnderDragonPart;
-import net.minecraft.world.entity.boss.enderdragon.EnderDragon;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.ChunkTickList;
 import net.minecraft.world.level.EmptyTickList;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.TickList;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.EntityBlock;
 import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.entity.BlockEntityTicker;
+import net.minecraft.world.level.block.entity.BlockEntityType;
+import net.minecraft.world.level.block.entity.TickingBlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.levelgen.DebugLevelSource;
 import net.minecraft.world.level.levelgen.Heightmap;
 import net.minecraft.world.level.levelgen.feature.StructureFeature;
 import net.minecraft.world.level.levelgen.structure.StructureStart;
 import net.minecraft.world.level.lighting.LevelLightEngine;
 import net.minecraft.world.level.material.Fluid;
 import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.level.material.Fluids;
-import net.minecraft.world.phys.AABB;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public class LevelChunk implements ChunkAccess {
    private static final Logger LOGGER = LogManager.getLogger();
+   private static final TickingBlockEntity NULL_TICKER = new TickingBlockEntity() {
+      public void tick() {
+      }
+
+      public boolean isRemoved() {
+         return true;
+      }
+
+      public BlockPos getPos() {
+         return BlockPos.ZERO;
+      }
+
+      public String getType() {
+         return "<null>";
+      }
+   };
    @Nullable
    public static final LevelChunkSection EMPTY_SECTION = null;
    private final LevelChunkSection[] sections;
    private ChunkBiomeContainer biomes;
    private final Map<BlockPos, CompoundTag> pendingBlockEntities;
+   private final Map<BlockPos, LevelChunk.RebindableTickingBlockEntityWrapper> tickersInLevel;
    private boolean loaded;
    private final Level level;
    private final Map<Heightmap.Types, Heightmap> heightmaps;
    private final UpgradeData upgradeData;
    private final Map<BlockPos, BlockEntity> blockEntities;
-   private final ClassInstanceMultiMap<Entity>[] entitySections;
    private final Map<StructureFeature<?>, StructureStart<?>> structureStarts;
    private final Map<StructureFeature<?>, LongSet> structuresRefences;
    private final ShortList[] postProcessing;
    private TickList<Block> blockTicks;
    private TickList<Fluid> liquidTicks;
-   private boolean lastSaveHadEntities;
-   private long lastSaveTime;
    private volatile boolean unsaved;
    private long inhabitedTime;
    @Nullable
    private Supplier<ChunkHolder.FullChunkStatus> fullStatus;
    @Nullable
@@ -89,18 +102,16 @@
    public LevelChunk(Level var1, ChunkPos var2, ChunkBiomeContainer var3) {
       this(var1, var2, var3, UpgradeData.EMPTY, EmptyTickList.empty(), EmptyTickList.empty(), 0L, (LevelChunkSection[])null, (Consumer)null);
    }
 
    public LevelChunk(Level var1, ChunkPos var2, ChunkBiomeContainer var3, UpgradeData var4, TickList<Block> var5, TickList<Fluid> var6, long var7, @Nullable LevelChunkSection[] var9, @Nullable Consumer<LevelChunk> var10) {
-      this.sections = new LevelChunkSection[16];
       this.pendingBlockEntities = Maps.newHashMap();
+      this.tickersInLevel = Maps.newHashMap();
       this.heightmaps = Maps.newEnumMap(Heightmap.Types.class);
       this.blockEntities = Maps.newHashMap();
       this.structureStarts = Maps.newHashMap();
       this.structuresRefences = Maps.newHashMap();
-      this.postProcessing = new ShortList[16];
-      this.entitySections = (ClassInstanceMultiMap[])(new ClassInstanceMultiMap[16]);
       this.level = var1;
       this.chunkPos = var2;
       this.upgradeData = var4;
       Heightmap.Types[] var11 = Heightmap.Types.values();
       int var12 = var11.length;
@@ -110,60 +121,48 @@
          if (ChunkStatus.FULL.heightmapsAfter().contains(var14)) {
             this.heightmaps.put(var14, new Heightmap(this, var14));
          }
       }
 
-      for(int var15 = 0; var15 < this.entitySections.length; ++var15) {
-         this.entitySections[var15] = new ClassInstanceMultiMap(Entity.class);
-      }
-
       this.biomes = var3;
       this.blockTicks = var5;
       this.liquidTicks = var6;
       this.inhabitedTime = var7;
       this.postLoad = var10;
+      this.sections = new LevelChunkSection[var1.getSectionsCount()];
       if (var9 != null) {
          if (this.sections.length == var9.length) {
             System.arraycopy(var9, 0, this.sections, 0, this.sections.length);
          } else {
             LOGGER.warn("Could not set level chunk sections, array length is {} instead of {}", var9.length, this.sections.length);
          }
       }
 
+      this.postProcessing = new ShortList[var1.getSectionsCount()];
    }
 
-   public LevelChunk(Level var1, ProtoChunk var2) {
-      this(var1, var2.getPos(), var2.getBiomes(), var2.getUpgradeData(), var2.getBlockTicks(), var2.getLiquidTicks(), var2.getInhabitedTime(), var2.getSections(), (Consumer)null);
-      Iterator var3 = var2.getEntities().iterator();
+   public LevelChunk(ServerLevel var1, ProtoChunk var2, @Nullable Consumer<LevelChunk> var3) {
+      this(var1, var2.getPos(), var2.getBiomes(), var2.getUpgradeData(), var2.getBlockTicks(), var2.getLiquidTicks(), var2.getInhabitedTime(), var2.getSections(), var3);
+      Iterator var4 = var2.getBlockEntities().values().iterator();
 
-      while(var3.hasNext()) {
-         CompoundTag var4 = (CompoundTag)var3.next();
-         EntityType.loadEntityRecursive(var4, var1, (var1x) -> {
-            this.addEntity(var1x);
-            return var1x;
-         });
+      while(var4.hasNext()) {
+         BlockEntity var5 = (BlockEntity)var4.next();
+         this.setBlockEntity(var5);
       }
 
-      var3 = var2.getBlockEntities().values().iterator();
-
-      while(var3.hasNext()) {
-         BlockEntity var6 = (BlockEntity)var3.next();
-         this.addBlockEntity(var6);
-      }
-
       this.pendingBlockEntities.putAll(var2.getBlockEntityNbts());
 
-      for(int var5 = 0; var5 < var2.getPostProcessing().length; ++var5) {
-         this.postProcessing[var5] = var2.getPostProcessing()[var5];
+      for(int var6 = 0; var6 < var2.getPostProcessing().length; ++var6) {
+         this.postProcessing[var6] = var2.getPostProcessing()[var6];
       }
 
       this.setAllStarts(var2.getAllStarts());
       this.setAllReferences(var2.getAllReferences());
-      var3 = var2.getHeightmaps().iterator();
+      var4 = var2.getHeightmaps().iterator();
 
-      while(var3.hasNext()) {
-         Entry var7 = (Entry)var3.next();
+      while(var4.hasNext()) {
+         Entry var7 = (Entry)var4.next();
          if (ChunkStatus.FULL.heightmapsAfter().contains(var7.getKey())) {
             this.getOrCreateHeightmapUnprimed((Heightmap.Types)var7.getKey()).setRawData(((Heightmap)var7.getValue()).getRawData());
          }
       }
 
@@ -202,23 +201,24 @@
          }
 
          return var9 == null ? Blocks.AIR.defaultBlockState() : var9;
       } else {
          try {
-            if (var3 >= 0 && var3 >> 4 < this.sections.length) {
-               LevelChunkSection var5 = this.sections[var3 >> 4];
-               if (!LevelChunkSection.isEmpty(var5)) {
-                  return var5.getBlockState(var2 & 15, var3 & 15, var4 & 15);
+            int var5 = this.getSectionIndex(var3);
+            if (var5 >= 0 && var5 < this.sections.length) {
+               LevelChunkSection var10 = this.sections[var5];
+               if (!LevelChunkSection.isEmpty(var10)) {
+                  return var10.getBlockState(var2 & 15, var3 & 15, var4 & 15);
                }
             }
 
             return Blocks.AIR.defaultBlockState();
          } catch (Throwable var8) {
             CrashReport var6 = CrashReport.forThrowable(var8, "Getting block state");
             CrashReportCategory var7 = var6.addCategory("Block being got");
             var7.setDetail("Location", () -> {
-               return CrashReportCategory.formatLocation(var2, var3, var4);
+               return CrashReportCategory.formatLocation(this, var2, var3, var4);
             });
             throw new ReportedException(var6);
          }
       }
    }
@@ -227,155 +227,115 @@
       return this.getFluidState(var1.getX(), var1.getY(), var1.getZ());
    }
 
    public FluidState getFluidState(int var1, int var2, int var3) {
       try {
-         if (var2 >= 0 && var2 >> 4 < this.sections.length) {
-            LevelChunkSection var4 = this.sections[var2 >> 4];
-            if (!LevelChunkSection.isEmpty(var4)) {
-               return var4.getFluidState(var1 & 15, var2 & 15, var3 & 15);
+         int var4 = this.getSectionIndex(var2);
+         if (var4 >= 0 && var4 < this.sections.length) {
+            LevelChunkSection var8 = this.sections[var4];
+            if (!LevelChunkSection.isEmpty(var8)) {
+               return var8.getFluidState(var1 & 15, var2 & 15, var3 & 15);
             }
          }
 
          return Fluids.EMPTY.defaultFluidState();
       } catch (Throwable var7) {
          CrashReport var5 = CrashReport.forThrowable(var7, "Getting fluid state");
          CrashReportCategory var6 = var5.addCategory("Block being got");
          var6.setDetail("Location", () -> {
-            return CrashReportCategory.formatLocation(var1, var2, var3);
+            return CrashReportCategory.formatLocation(this, var1, var2, var3);
          });
          throw new ReportedException(var5);
       }
    }
 
    @Nullable
    public BlockState setBlockState(BlockPos var1, BlockState var2, boolean var3) {
-      int var4 = var1.getX() & 15;
-      int var5 = var1.getY();
-      int var6 = var1.getZ() & 15;
-      LevelChunkSection var7 = this.sections[var5 >> 4];
-      if (var7 == EMPTY_SECTION) {
+      int var4 = var1.getY();
+      int var5 = this.getSectionIndex(var4);
+      LevelChunkSection var6 = this.sections[var5];
+      if (var6 == EMPTY_SECTION) {
          if (var2.isAir()) {
             return null;
          }
 
-         var7 = new LevelChunkSection(var5 >> 4 << 4);
-         this.sections[var5 >> 4] = var7;
+         var6 = new LevelChunkSection(SectionPos.blockToSectionCoord(var4));
+         this.sections[var5] = var6;
       }
 
-      boolean var8 = var7.isEmpty();
-      BlockState var9 = var7.setBlockState(var4, var5 & 15, var6, var2);
-      if (var9 == var2) {
+      boolean var7 = var6.isEmpty();
+      int var8 = var1.getX() & 15;
+      int var9 = var4 & 15;
+      int var10 = var1.getZ() & 15;
+      BlockState var11 = var6.setBlockState(var8, var9, var10, var2);
+      if (var11 == var2) {
          return null;
       } else {
-         Block var10 = var2.getBlock();
-         Block var11 = var9.getBlock();
-         ((Heightmap)this.heightmaps.get(Heightmap.Types.MOTION_BLOCKING)).update(var4, var5, var6, var2);
-         ((Heightmap)this.heightmaps.get(Heightmap.Types.MOTION_BLOCKING_NO_LEAVES)).update(var4, var5, var6, var2);
-         ((Heightmap)this.heightmaps.get(Heightmap.Types.OCEAN_FLOOR)).update(var4, var5, var6, var2);
-         ((Heightmap)this.heightmaps.get(Heightmap.Types.WORLD_SURFACE)).update(var4, var5, var6, var2);
-         boolean var12 = var7.isEmpty();
-         if (var8 != var12) {
-            this.level.getChunkSource().getLightEngine().updateSectionStatus(var1, var12);
+         Block var12 = var2.getBlock();
+         ((Heightmap)this.heightmaps.get(Heightmap.Types.MOTION_BLOCKING)).update(var8, var4, var10, var2);
+         ((Heightmap)this.heightmaps.get(Heightmap.Types.MOTION_BLOCKING_NO_LEAVES)).update(var8, var4, var10, var2);
+         ((Heightmap)this.heightmaps.get(Heightmap.Types.OCEAN_FLOOR)).update(var8, var4, var10, var2);
+         ((Heightmap)this.heightmaps.get(Heightmap.Types.WORLD_SURFACE)).update(var8, var4, var10, var2);
+         boolean var13 = var6.isEmpty();
+         if (var7 != var13) {
+            this.level.getChunkSource().getLightEngine().updateSectionStatus(var1, var13);
          }
 
+         boolean var14 = var11.hasBlockEntity();
          if (!this.level.isClientSide) {
-            var9.onRemove(this.level, var1, var2, var3);
-         } else if (var11 != var10 && var11 instanceof EntityBlock) {
-            this.level.removeBlockEntity(var1);
+            var11.onRemove(this.level, var1, var2, var3);
+         } else if (!var11.is(var12) && var14) {
+            this.removeBlockEntity(var1);
          }
 
-         if (!var7.getBlockState(var4, var5 & 15, var6).is(var10)) {
+         if (!var6.getBlockState(var8, var9, var10).is(var12)) {
             return null;
          } else {
-            BlockEntity var13;
-            if (var11 instanceof EntityBlock) {
-               var13 = this.getBlockEntity(var1, LevelChunk.EntityCreationType.CHECK);
-               if (var13 != null) {
-                  var13.clearCache();
-               }
-            }
-
             if (!this.level.isClientSide) {
-               var2.onPlace(this.level, var1, var9, var3);
+               var2.onPlace(this.level, var1, var11, var3);
             }
 
-            if (var10 instanceof EntityBlock) {
-               var13 = this.getBlockEntity(var1, LevelChunk.EntityCreationType.CHECK);
-               if (var13 == null) {
-                  var13 = ((EntityBlock)var10).newBlockEntity(this.level);
-                  this.level.setBlockEntity(var1, var13);
+            if (var2.hasBlockEntity()) {
+               BlockEntity var15 = this.getBlockEntity(var1, LevelChunk.EntityCreationType.CHECK);
+               if (var15 == null) {
+                  var15 = ((EntityBlock)var12).newBlockEntity(var1, var2);
+                  if (var15 != null) {
+                     this.addAndRegisterBlockEntity(var15);
+                  }
                } else {
-                  var13.clearCache();
+                  var15.setBlockState(var2);
+                  this.updateBlockEntityTicker(var15);
                }
             }
 
             this.unsaved = true;
-            return var9;
+            return var11;
          }
       }
    }
 
    @Nullable
    public LevelLightEngine getLightEngine() {
       return this.level.getChunkSource().getLightEngine();
    }
 
+   @Deprecated
    public void addEntity(Entity var1) {
-      this.lastSaveHadEntities = true;
-      int var2 = Mth.floor(var1.getX() / 16.0D);
-      int var3 = Mth.floor(var1.getZ() / 16.0D);
-      if (var2 != this.chunkPos.x || var3 != this.chunkPos.z) {
-         LOGGER.warn("Wrong location! ({}, {}) should be ({}, {}), {}", var2, var3, this.chunkPos.x, this.chunkPos.z, var1);
-         var1.removed = true;
-      }
-
-      int var4 = Mth.floor(var1.getY() / 16.0D);
-      if (var4 < 0) {
-         var4 = 0;
-      }
-
-      if (var4 >= this.entitySections.length) {
-         var4 = this.entitySections.length - 1;
-      }
-
-      var1.inChunk = true;
-      var1.xChunk = this.chunkPos.x;
-      var1.yChunk = var4;
-      var1.zChunk = this.chunkPos.z;
-      this.entitySections[var4].add(var1);
    }
 
    public void setHeightmap(Heightmap.Types var1, long[] var2) {
       ((Heightmap)this.heightmaps.get(var1)).setRawData(var2);
    }
 
-   public void removeEntity(Entity var1) {
-      this.removeEntity(var1, var1.yChunk);
-   }
-
-   public void removeEntity(Entity var1, int var2) {
-      if (var2 < 0) {
-         var2 = 0;
-      }
-
-      if (var2 >= this.entitySections.length) {
-         var2 = this.entitySections.length - 1;
-      }
-
-      this.entitySections[var2].remove(var1);
-   }
-
    public int getHeight(Heightmap.Types var1, int var2, int var3) {
       return ((Heightmap)this.heightmaps.get(var1)).getFirstAvailable(var2 & 15, var3 & 15) - 1;
    }
 
    @Nullable
    private BlockEntity createBlockEntity(BlockPos var1) {
       BlockState var2 = this.getBlockState(var1);
-      Block var3 = var2.getBlock();
-      return !var3.isEntityBlock() ? null : ((EntityBlock)var3).newBlockEntity(this.level);
+      return !var2.hasBlockEntity() ? null : ((EntityBlock)var2.getBlock()).newBlockEntity(var1, var2);
    }
 
    @Nullable
    public BlockEntity getBlockEntity(BlockPos var1) {
       return this.getBlockEntity(var1, LevelChunk.EntityCreationType.CHECK);
@@ -395,34 +355,45 @@
       }
 
       if (var3 == null) {
          if (var2 == LevelChunk.EntityCreationType.IMMEDIATE) {
             var3 = this.createBlockEntity(var1);
-            this.level.setBlockEntity(var1, var3);
+            if (var3 != null) {
+               this.addAndRegisterBlockEntity(var3);
+            }
          }
       } else if (var3.isRemoved()) {
          this.blockEntities.remove(var1);
          return null;
       }
 
       return var3;
    }
 
-   public void addBlockEntity(BlockEntity var1) {
-      this.setBlockEntity(var1.getBlockPos(), var1);
-      if (this.loaded || this.level.isClientSide()) {
-         this.level.setBlockEntity(var1.getBlockPos(), var1);
+   public void addAndRegisterBlockEntity(BlockEntity var1) {
+      this.setBlockEntity(var1);
+      if (this.isInLevel()) {
+         this.updateBlockEntityTicker(var1);
       }
 
    }
 
-   public void setBlockEntity(BlockPos var1, BlockEntity var2) {
-      if (this.getBlockState(var1).getBlock() instanceof EntityBlock) {
-         var2.setLevelAndPosition(this.level, var1);
-         var2.clearRemoved();
-         BlockEntity var3 = (BlockEntity)this.blockEntities.put(var1.immutable(), var2);
-         if (var3 != null && var3 != var2) {
+   private boolean isInLevel() {
+      return this.loaded || this.level.isClientSide();
+   }
+
+   private boolean isTicking(BlockPos var1) {
+      return (this.level.isClientSide() || this.getFullStatus().isOrAfter(ChunkHolder.FullChunkStatus.TICKING)) && this.level.getWorldBorder().isWithinBounds(var1);
+   }
+
+   public void setBlockEntity(BlockEntity var1) {
+      BlockPos var2 = var1.getBlockPos();
+      if (this.getBlockState(var2).hasBlockEntity()) {
+         var1.setLevel(this.level);
+         var1.clearRemoved();
+         BlockEntity var3 = (BlockEntity)this.blockEntities.put(var2.immutable(), var1);
+         if (var3 != null && var3 != var1) {
             var3.setRemoved();
          }
 
       }
    }
@@ -449,19 +420,28 @@
          return var3;
       }
    }
 
    public void removeBlockEntity(BlockPos var1) {
-      if (this.loaded || this.level.isClientSide()) {
+      if (this.isInLevel()) {
          BlockEntity var2 = (BlockEntity)this.blockEntities.remove(var1);
          if (var2 != null) {
             var2.setRemoved();
          }
       }
 
+      this.removeBlockEntityTicker(var1);
    }
 
+   private void removeBlockEntityTicker(BlockPos var1) {
+      LevelChunk.RebindableTickingBlockEntityWrapper var2 = (LevelChunk.RebindableTickingBlockEntityWrapper)this.tickersInLevel.remove(var1);
+      if (var2 != null) {
+         var2.rebind(NULL_TICKER);
+      }
+
+   }
+
    public void runPostLoad() {
       if (this.postLoad != null) {
          this.postLoad.accept(this);
          this.postLoad = null;
       }
@@ -470,158 +450,74 @@
 
    public void markUnsaved() {
       this.unsaved = true;
    }
 
-   public void getEntities(@Nullable Entity var1, AABB var2, List<Entity> var3, @Nullable Predicate<? super Entity> var4) {
-      int var5 = Mth.floor((var2.minY - 2.0D) / 16.0D);
-      int var6 = Mth.floor((var2.maxY + 2.0D) / 16.0D);
-      var5 = Mth.clamp(var5, 0, this.entitySections.length - 1);
-      var6 = Mth.clamp(var6, 0, this.entitySections.length - 1);
-
-      for(int var7 = var5; var7 <= var6; ++var7) {
-         ClassInstanceMultiMap var8 = this.entitySections[var7];
-         List var9 = var8.getAllInstances();
-         int var10 = var9.size();
-
-         for(int var11 = 0; var11 < var10; ++var11) {
-            Entity var12 = (Entity)var9.get(var11);
-            if (var12.getBoundingBox().intersects(var2) && var12 != var1) {
-               if (var4 == null || var4.test(var12)) {
-                  var3.add(var12);
-               }
-
-               if (var12 instanceof EnderDragon) {
-                  EnderDragonPart[] var13 = ((EnderDragon)var12).getSubEntities();
-                  int var14 = var13.length;
-
-                  for(int var15 = 0; var15 < var14; ++var15) {
-                     EnderDragonPart var16 = var13[var15];
-                     if (var16 != var1 && var16.getBoundingBox().intersects(var2) && (var4 == null || var4.test(var16))) {
-                        var3.add(var16);
-                     }
-                  }
-               }
-            }
-         }
-      }
-
-   }
-
-   public <T extends Entity> void getEntities(@Nullable EntityType<?> var1, AABB var2, List<? super T> var3, Predicate<? super T> var4) {
-      int var5 = Mth.floor((var2.minY - 2.0D) / 16.0D);
-      int var6 = Mth.floor((var2.maxY + 2.0D) / 16.0D);
-      var5 = Mth.clamp(var5, 0, this.entitySections.length - 1);
-      var6 = Mth.clamp(var6, 0, this.entitySections.length - 1);
-
-      label33:
-      for(int var7 = var5; var7 <= var6; ++var7) {
-         Iterator var8 = this.entitySections[var7].find(Entity.class).iterator();
-
-         while(true) {
-            Entity var9;
-            do {
-               if (!var8.hasNext()) {
-                  continue label33;
-               }
-
-               var9 = (Entity)var8.next();
-            } while(var1 != null && var9.getType() != var1);
-
-            if (var9.getBoundingBox().intersects(var2) && var4.test(var9)) {
-               var3.add(var9);
-            }
-         }
-      }
-
-   }
-
-   public <T extends Entity> void getEntitiesOfClass(Class<? extends T> var1, AABB var2, List<T> var3, @Nullable Predicate<? super T> var4) {
-      int var5 = Mth.floor((var2.minY - 2.0D) / 16.0D);
-      int var6 = Mth.floor((var2.maxY + 2.0D) / 16.0D);
-      var5 = Mth.clamp(var5, 0, this.entitySections.length - 1);
-      var6 = Mth.clamp(var6, 0, this.entitySections.length - 1);
-
-      label33:
-      for(int var7 = var5; var7 <= var6; ++var7) {
-         Iterator var8 = this.entitySections[var7].find(var1).iterator();
-
-         while(true) {
-            Entity var9;
-            do {
-               do {
-                  if (!var8.hasNext()) {
-                     continue label33;
-                  }
-
-                  var9 = (Entity)var8.next();
-               } while(!var9.getBoundingBox().intersects(var2));
-            } while(var4 != null && !var4.test(var9));
-
-            var3.add(var9);
-         }
-      }
-
-   }
-
    public boolean isEmpty() {
       return false;
    }
 
    public ChunkPos getPos() {
       return this.chunkPos;
    }
 
    public void replaceWithPacketData(@Nullable ChunkBiomeContainer var1, FriendlyByteBuf var2, CompoundTag var3, int var4) {
       boolean var5 = var1 != null;
-      Predicate var6 = var5 ? (var0) -> {
-         return true;
-      } : (var1x) -> {
-         return (var4 & 1 << (var1x.getY() >> 4)) != 0;
-      };
-      Stream var10000 = Sets.newHashSet(this.blockEntities.keySet()).stream().filter(var6);
-      Level var10001 = this.level;
-      var10000.forEach(var10001::removeBlockEntity);
+      if (var5) {
+         this.blockEntities.values().forEach(this::onBlockEntityRemove);
+         this.blockEntities.clear();
+      } else {
+         this.blockEntities.values().removeIf((var2x) -> {
+            if (this.isPositionInSection(var4, var2x.getBlockPos())) {
+               var2x.setRemoved();
+               return true;
+            } else {
+               return false;
+            }
+         });
+      }
 
-      for(int var7 = 0; var7 < this.sections.length; ++var7) {
-         LevelChunkSection var8 = this.sections[var7];
-         if ((var4 & 1 << var7) == 0) {
-            if (var5 && var8 != EMPTY_SECTION) {
-               this.sections[var7] = EMPTY_SECTION;
+      for(int var6 = 0; var6 < this.sections.length; ++var6) {
+         LevelChunkSection var7 = this.sections[var6];
+         if ((var4 & 1 << var6) == 0) {
+            if (var5 && var7 != EMPTY_SECTION) {
+               this.sections[var6] = EMPTY_SECTION;
             }
          } else {
-            if (var8 == EMPTY_SECTION) {
-               var8 = new LevelChunkSection(var7 << 4);
-               this.sections[var7] = var8;
+            if (var7 == EMPTY_SECTION) {
+               var7 = new LevelChunkSection(this.getSectionYFromSectionIndex(var6));
+               this.sections[var6] = var7;
             }
 
-            var8.read(var2);
+            var7.read(var2);
          }
       }
 
       if (var1 != null) {
          this.biomes = var1;
       }
 
-      Heightmap.Types[] var12 = Heightmap.Types.values();
-      int var14 = var12.length;
+      Heightmap.Types[] var11 = Heightmap.Types.values();
+      int var12 = var11.length;
 
-      for(int var9 = 0; var9 < var14; ++var9) {
-         Heightmap.Types var10 = var12[var9];
-         String var11 = var10.getSerializationKey();
-         if (var3.contains(var11, 12)) {
-            this.setHeightmap(var10, var3.getLongArray(var11));
+      for(int var8 = 0; var8 < var12; ++var8) {
+         Heightmap.Types var9 = var11[var8];
+         String var10 = var9.getSerializationKey();
+         if (var3.contains(var10, 12)) {
+            this.setHeightmap(var9, var3.getLongArray(var10));
          }
       }
 
-      Iterator var13 = this.blockEntities.values().iterator();
+   }
 
-      while(var13.hasNext()) {
-         BlockEntity var15 = (BlockEntity)var13.next();
-         var15.clearCache();
-      }
+   private void onBlockEntityRemove(BlockEntity var1) {
+      var1.setRemoved();
+      this.tickersInLevel.remove(var1.getBlockPos());
+   }
 
+   private boolean isPositionInSection(int var1, BlockPos var2) {
+      return (var1 & 1 << this.getSectionIndex(var2.getY())) != 0;
    }
 
    public ChunkBiomeContainer getBiomes() {
       return this.biomes;
    }
@@ -640,20 +536,16 @@
 
    public Map<BlockPos, BlockEntity> getBlockEntities() {
       return this.blockEntities;
    }
 
-   public ClassInstanceMultiMap<Entity>[] getEntitySections() {
-      return this.entitySections;
-   }
-
    public CompoundTag getBlockEntityNbt(BlockPos var1) {
       return (CompoundTag)this.pendingBlockEntities.get(var1);
    }
 
    public Stream<BlockPos> getLights() {
-      return StreamSupport.stream(BlockPos.betweenClosed(this.chunkPos.getMinBlockX(), 0, this.chunkPos.getMinBlockZ(), this.chunkPos.getMaxBlockX(), 255, this.chunkPos.getMaxBlockZ()).spliterator(), false).filter((var1) -> {
+      return StreamSupport.stream(BlockPos.betweenClosed(this.chunkPos.getMinBlockX(), 0, this.chunkPos.getMinBlockZ(), this.chunkPos.getMaxBlockX(), this.getMaxBuildHeight() - 1, this.chunkPos.getMaxBlockZ()).spliterator(), false).filter((var1) -> {
          return this.getBlockState(var1).getLightEmission() != 0;
       });
    }
 
    public TickList<Block> getBlockTicks() {
@@ -667,21 +559,13 @@
    public void setUnsaved(boolean var1) {
       this.unsaved = var1;
    }
 
    public boolean isUnsaved() {
-      return this.unsaved || this.lastSaveHadEntities && this.level.getGameTime() != this.lastSaveTime;
+      return this.unsaved;
    }
 
-   public void setLastSaveHadEntities(boolean var1) {
-      this.lastSaveHadEntities = var1;
-   }
-
-   public void setLastSaveTime(long var1) {
-      this.lastSaveTime = var1;
-   }
-
    @Nullable
    public StructureStart<?> getStartForFeature(StructureFeature<?> var1) {
       return (StructureStart)this.structureStarts.get(var1);
    }
 
@@ -734,22 +618,22 @@
          if (this.postProcessing[var2] != null) {
             ShortListIterator var3 = this.postProcessing[var2].iterator();
 
             while(var3.hasNext()) {
                Short var4 = (Short)var3.next();
-               BlockPos var5 = ProtoChunk.unpackOffsetCoordinates(var4, var2, var1);
+               BlockPos var5 = ProtoChunk.unpackOffsetCoordinates(var4, this.getSectionYFromSectionIndex(var2), var1);
                BlockState var6 = this.getBlockState(var5);
                BlockState var7 = Block.updateFromNeighbourShapes(var6, this.level, var5);
                this.level.setBlock(var5, var7, 20);
             }
 
             this.postProcessing[var2].clear();
          }
       }
 
       this.unpackTicks();
-      Iterator var8 = Sets.newHashSet(this.pendingBlockEntities.keySet()).iterator();
+      UnmodifiableIterator var8 = ImmutableList.copyOf(this.pendingBlockEntities.keySet()).iterator();
 
       while(var8.hasNext()) {
          BlockPos var9 = (BlockPos)var8.next();
          this.getBlockEntity(var9);
       }
@@ -761,24 +645,23 @@
    @Nullable
    private BlockEntity promotePendingBlockEntity(BlockPos var1, CompoundTag var2) {
       BlockState var4 = this.getBlockState(var1);
       BlockEntity var3;
       if ("DUMMY".equals(var2.getString("id"))) {
-         Block var5 = var4.getBlock();
-         if (var5 instanceof EntityBlock) {
-            var3 = ((EntityBlock)var5).newBlockEntity(this.level);
+         if (var4.hasBlockEntity()) {
+            var3 = ((EntityBlock)var4.getBlock()).newBlockEntity(var1, var4);
          } else {
             var3 = null;
             LOGGER.warn("Tried to load a DUMMY block entity @ {} but found not block entity block {} at location", var1, var4);
          }
       } else {
-         var3 = BlockEntity.loadStatic(var4, var2);
+         var3 = BlockEntity.loadStatic(var1, var4, var2);
       }
 
       if (var3 != null) {
-         var3.setLevelAndPosition(this.level, var1);
-         this.addBlockEntity(var3);
+         var3.setLevel(this.level);
+         this.addAndRegisterBlockEntity(var3);
       } else {
          LOGGER.warn("Tried to load a block entity for block {} but failed at location {}", var4, var1);
       }
 
       return var3;
@@ -826,10 +709,18 @@
          this.setUnsaved(true);
       }
 
    }
 
+   public int getSectionsCount() {
+      return this.level.getSectionsCount();
+   }
+
+   public int getMinSection() {
+      return this.level.getMinSection();
+   }
+
    public ChunkStatus getStatus() {
       return ChunkStatus.FULL;
    }
 
    public ChunkHolder.FullChunkStatus getFullStatus() {
@@ -847,10 +738,134 @@
    public void setLightCorrect(boolean var1) {
       this.isLightCorrect = var1;
       this.setUnsaved(true);
    }
 
+   public void invalidateAllBlockEntities() {
+      this.blockEntities.values().forEach(this::onBlockEntityRemove);
+   }
+
+   public void registerAllBlockEntitiesAfterLevelLoad() {
+      this.blockEntities.values().forEach(this::updateBlockEntityTicker);
+   }
+
+   private <T extends BlockEntity> void updateBlockEntityTicker(T var1) {
+      BlockState var2 = var1.getBlockState();
+      BlockEntityTicker var3 = var2.getTicker(this.level, var1.getType());
+      if (var3 == null) {
+         this.removeBlockEntityTicker(var1.getBlockPos());
+      } else {
+         this.tickersInLevel.compute(var1.getBlockPos(), (var3x, var4) -> {
+            TickingBlockEntity var5 = this.createTicker(var1, var3);
+            if (var4 != null) {
+               var4.rebind(var5);
+               return var4;
+            } else if (this.isInLevel()) {
+               LevelChunk.RebindableTickingBlockEntityWrapper var6 = new LevelChunk.RebindableTickingBlockEntityWrapper(var5);
+               this.level.addBlockEntityTicker(var6);
+               return var6;
+            } else {
+               return null;
+            }
+         });
+      }
+
+   }
+
+   private <T extends BlockEntity> TickingBlockEntity createTicker(T var1, BlockEntityTicker<T> var2) {
+      return new LevelChunk.BoundTickingBlockEntity(var1, var2);
+   }
+
+   class RebindableTickingBlockEntityWrapper implements TickingBlockEntity {
+      private TickingBlockEntity ticker;
+
+      private RebindableTickingBlockEntityWrapper(TickingBlockEntity var2) {
+         this.ticker = var2;
+      }
+
+      private void rebind(TickingBlockEntity var1) {
+         this.ticker = var1;
+      }
+
+      public void tick() {
+         this.ticker.tick();
+      }
+
+      public boolean isRemoved() {
+         return this.ticker.isRemoved();
+      }
+
+      public BlockPos getPos() {
+         return this.ticker.getPos();
+      }
+
+      public String getType() {
+         return this.ticker.getType();
+      }
+
+      public String toString() {
+         return this.ticker.toString() + " <wrapped>";
+      }
+   }
+
+   class BoundTickingBlockEntity<T extends BlockEntity> implements TickingBlockEntity {
+      private final T blockEntity;
+      private final BlockEntityTicker<T> ticker;
+      private boolean loggedInvalidBlockState;
+
+      private BoundTickingBlockEntity(T var2, BlockEntityTicker<T> var3) {
+         this.blockEntity = var2;
+         this.ticker = var3;
+      }
+
+      public void tick() {
+         if (!this.blockEntity.isRemoved() && this.blockEntity.hasLevel()) {
+            BlockPos var1 = this.blockEntity.getBlockPos();
+            if (LevelChunk.this.isTicking(var1)) {
+               try {
+                  ProfilerFiller var2 = LevelChunk.this.level.getProfiler();
+                  var2.push(this::getType);
+                  BlockState var6 = LevelChunk.this.getBlockState(var1);
+                  if (this.blockEntity.getType().isValid(var6)) {
+                     this.ticker.tick(LevelChunk.this.level, this.blockEntity.getBlockPos(), var6, this.blockEntity);
+                     this.loggedInvalidBlockState = false;
+                  } else if (!this.loggedInvalidBlockState) {
+                     this.loggedInvalidBlockState = true;
+                     LevelChunk.LOGGER.warn("Block entity {} @ {} state {} invalid for ticking:", new org.apache.logging.log4j.util.Supplier[]{this::getType, this::getPos, () -> {
+                        return var6;
+                     }});
+                  }
+
+                  var2.pop();
+               } catch (Throwable var5) {
+                  CrashReport var3 = CrashReport.forThrowable(var5, "Ticking block entity");
+                  CrashReportCategory var4 = var3.addCategory("Block entity being ticked");
+                  this.blockEntity.fillCrashReportCategory(var4);
+                  throw new ReportedException(var3);
+               }
+            }
+         }
+
+      }
+
+      public boolean isRemoved() {
+         return this.blockEntity.isRemoved();
+      }
+
+      public BlockPos getPos() {
+         return this.blockEntity.getBlockPos();
+      }
+
+      public String getType() {
+         return BlockEntityType.getKey(this.blockEntity.getType()).toString();
+      }
+
+      public String toString() {
+         return "Level ticker for " + this.getType() + "@" + this.getPos();
+      }
+   }
+
    public static enum EntityCreationType {
       IMMEDIATE,
       QUEUED,
       CHECK;
 
