--- net/minecraft/client/profiling/metric/MetricSampler.java
+++ net/minecraft/client/profiling/metric/MetricSampler.java
@@ -1,0 +1,154 @@
+package net.minecraft.client.profiling.metric;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import java.util.function.Consumer;
+import java.util.function.DoubleConsumer;
+import java.util.function.DoubleSupplier;
+import java.util.function.ToDoubleFunction;
+import javax.annotation.Nullable;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.util.profiling.registry.Metric;
+
+public class MetricSampler {
+   private final Metric metric;
+   private final DoubleSupplier sampler;
+   private final ByteBuf values;
+   private volatile boolean isRunning;
+   @Nullable
+   private final Runnable beforeTick;
+   @Nullable
+   private final MetricSampler.ThresholdAlerter thresholdAlerter;
+
+   private <T> MetricSampler(Metric var1, DoubleSupplier var2, @Nullable Runnable var3, @Nullable MetricSampler.ThresholdAlerter var4) {
+      this.metric = var1;
+      this.beforeTick = var3;
+      this.sampler = var2;
+      this.thresholdAlerter = var4;
+      this.values = new FriendlyByteBuf(Unpooled.directBuffer());
+      this.isRunning = true;
+   }
+
+   public static MetricSampler create(Metric var0, DoubleSupplier var1) {
+      return new MetricSampler(var0, var1, (Runnable)null, (MetricSampler.ThresholdAlerter)null);
+   }
+
+   public static MetricSampler create(String var0, DoubleSupplier var1) {
+      return create(new Metric(var0), var1);
+   }
+
+   public static <T> MetricSampler create(String var0, T var1, ToDoubleFunction<T> var2) {
+      return builder(var0, var2, var1).build();
+   }
+
+   public static <T> MetricSampler.MetricSamplerBuilder<T> builder(String var0, ToDoubleFunction<T> var1, T var2) {
+      return new MetricSampler.MetricSamplerBuilder(new Metric(var0), var1, var2);
+   }
+
+   public int numberOfValues() {
+      return this.values.readableBytes() / 8;
+   }
+
+   public void onStartTick() {
+      if (!this.isRunning) {
+         throw new IllegalStateException("Not running");
+      } else {
+         if (this.beforeTick != null) {
+            this.beforeTick.run();
+         }
+
+      }
+   }
+
+   public void onEndTick() {
+      this.verifyRunning();
+      double var1 = this.sampler.getAsDouble();
+      this.values.writeDouble(var1);
+      if (this.thresholdAlerter != null) {
+         this.thresholdAlerter.test(var1);
+      }
+
+   }
+
+   public void onFinished() {
+      this.verifyRunning();
+      this.values.release();
+      this.isRunning = false;
+   }
+
+   private void verifyRunning() {
+      if (!this.isRunning) {
+         throw new IllegalStateException(String.format("Sampler for metric %s not started!", this.metric.getName()));
+      }
+   }
+
+   public Metric getMetric() {
+      return this.metric;
+   }
+
+   public boolean hasMoreValues() {
+      return this.values.isReadable(8);
+   }
+
+   public double readNextValue() {
+      return this.values.readDouble();
+   }
+
+   public static class MetricSamplerBuilder<T> {
+      private final Metric metric;
+      private final DoubleSupplier sampler;
+      private final T context;
+      @Nullable
+      private Runnable beforeTick = null;
+      @Nullable
+      private MetricSampler.ThresholdAlerter thresholdAlerter;
+
+      public MetricSamplerBuilder(Metric var1, ToDoubleFunction<T> var2, T var3) {
+         this.metric = var1;
+         this.sampler = () -> {
+            return var2.applyAsDouble(var3);
+         };
+         this.context = var3;
+      }
+
+      public MetricSampler.MetricSamplerBuilder<T> withBeforeTick(Consumer<T> var1) {
+         this.beforeTick = () -> {
+            var1.accept(this.context);
+         };
+         return this;
+      }
+
+      public MetricSampler.MetricSamplerBuilder<T> withThresholdAlert(MetricSampler.ThresholdAlerter var1) {
+         this.thresholdAlerter = var1;
+         return this;
+      }
+
+      public MetricSampler build() {
+         return new MetricSampler(this.metric, this.sampler, this.beforeTick, this.thresholdAlerter);
+      }
+   }
+
+   public static class ValueIncreased implements MetricSampler.ThresholdAlerter {
+      private final float percentageIncreaseThreshold;
+      private final DoubleConsumer action;
+      private double previousValue = Double.MIN_VALUE;
+
+      public ValueIncreased(float var1, DoubleConsumer var2) {
+         this.percentageIncreaseThreshold = var1;
+         this.action = var2;
+      }
+
+      public void test(double var1) {
+         boolean var3 = this.previousValue != Double.MIN_VALUE && var1 > this.previousValue && (var1 - this.previousValue) / this.previousValue >= (double)this.percentageIncreaseThreshold;
+         if (var3) {
+            this.action.accept(var1);
+         }
+
+         this.previousValue = var1;
+      }
+   }
+
+   public interface ThresholdAlerter {
+      void test(double var1);
+   }
+}
