--- net/minecraft/world/level/block/BigDripleafBlock.java
+++ net/minecraft/world/level/block/BigDripleafBlock.java
@@ -1,0 +1,249 @@
+package net.minecraft.world.level.block;
+
+import com.google.common.collect.ImmutableMap;
+import it.unimi.dsi.fastutil.objects.Object2IntArrayMap;
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import java.util.Map;
+import java.util.Random;
+import java.util.function.Predicate;
+import javax.annotation.Nullable;
+import net.minecraft.Util;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.sounds.SoundEvent;
+import net.minecraft.sounds.SoundEvents;
+import net.minecraft.sounds.SoundSource;
+import net.minecraft.tags.FluidTags;
+import net.minecraft.util.Mth;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntitySelector;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.entity.projectile.Projectile;
+import net.minecraft.world.item.context.BlockPlaceContext;
+import net.minecraft.world.level.BlockGetter;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.LevelAccessor;
+import net.minecraft.world.level.LevelReader;
+import net.minecraft.world.level.block.state.BlockBehaviour;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.StateDefinition;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
+import net.minecraft.world.level.block.state.properties.BooleanProperty;
+import net.minecraft.world.level.block.state.properties.EnumProperty;
+import net.minecraft.world.level.block.state.properties.Tilt;
+import net.minecraft.world.level.gameevent.GameEvent;
+import net.minecraft.world.level.material.Fluid;
+import net.minecraft.world.level.material.FluidState;
+import net.minecraft.world.level.material.Fluids;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.shapes.CollisionContext;
+import net.minecraft.world.phys.shapes.Shapes;
+import net.minecraft.world.phys.shapes.VoxelShape;
+
+public class BigDripleafBlock extends HorizontalDirectionalBlock implements BonemealableBlock, SimpleWaterloggedBlock {
+   private static final BooleanProperty WATERLOGGED;
+   private static final EnumProperty<Tilt> TILT;
+   private static final Object2IntMap<Tilt> DELAY_UNTIL_NEXT_TILT_STATE;
+   private static final AABB ENTITY_DETECTION_SHAPE;
+   private static final Map<Tilt, VoxelShape> LEAF_SHAPES;
+   private static final Map<Direction, VoxelShape> STEM_SHAPES;
+   private final Map<BlockState, VoxelShape> shapesCache;
+
+   protected BigDripleafBlock(BlockBehaviour.Properties var1) {
+      super(var1);
+      this.registerDefaultState((BlockState)((BlockState)((BlockState)((BlockState)this.stateDefinition.any()).setValue(WATERLOGGED, false)).setValue(FACING, Direction.NORTH)).setValue(TILT, Tilt.NONE));
+      this.shapesCache = this.getShapeForEachState(BigDripleafBlock::calculateShape);
+   }
+
+   protected static VoxelShape calculateShape(BlockState var0) {
+      return Shapes.or(getLeafShape(var0), getStemShape(var0));
+   }
+
+   private static VoxelShape getStemShape(BlockState var0) {
+      return (VoxelShape)STEM_SHAPES.get(var0.getValue(FACING));
+   }
+
+   private static VoxelShape getLeafShape(BlockState var0) {
+      return (VoxelShape)LEAF_SHAPES.get(var0.getValue(TILT));
+   }
+
+   protected static void place(Level var0, Random var1, BlockPos var2) {
+      int var3 = var0.getMaxBuildHeight() - var2.getY();
+      int var4 = 1 + var1.nextInt(5);
+      int var5 = Math.min(var4, var3);
+      Direction var6 = Direction.Plane.HORIZONTAL.getRandomDirection(var1);
+      BlockPos.MutableBlockPos var7 = var2.mutable();
+
+      for(int var8 = 0; var8 < var5; ++var8) {
+         Block var9 = var8 == var5 - 1 ? Blocks.BIG_DRIPLEAF : Blocks.BIG_DRIPLEAF_STEM;
+         BlockState var10 = (BlockState)((BlockState)var9.defaultBlockState().setValue(WATERLOGGED, var0.getFluidState(var7).getType() == Fluids.WATER)).setValue(HorizontalDirectionalBlock.FACING, var6);
+         var0.setBlock(var7, var10, 2);
+         var7.move(Direction.UP);
+      }
+
+   }
+
+   public void onProjectileHit(Level var1, BlockState var2, BlockHitResult var3, Projectile var4) {
+      var1.destroyBlock(var3.getBlockPos(), true, var4);
+   }
+
+   public FluidState getFluidState(BlockState var1) {
+      return (Boolean)var1.getValue(WATERLOGGED) ? Fluids.WATER.getSource(false) : super.getFluidState(var1);
+   }
+
+   public boolean canSurvive(BlockState var1, LevelReader var2, BlockPos var3) {
+      BlockPos var4 = var3.below();
+      BlockState var5 = var2.getBlockState(var4);
+      return var5.is(Blocks.BIG_DRIPLEAF_STEM) || var5.isFaceSturdy(var2, var4, Direction.UP);
+   }
+
+   public BlockState updateShape(BlockState var1, Direction var2, BlockState var3, LevelAccessor var4, BlockPos var5, BlockPos var6) {
+      if (!var1.canSurvive(var4, var5)) {
+         var4.destroyBlock(var5, true);
+      }
+
+      if ((Boolean)var1.getValue(WATERLOGGED)) {
+         var4.getLiquidTicks().scheduleTick(var5, Fluids.WATER, Fluids.WATER.getTickDelay(var4));
+      }
+
+      return super.updateShape(var1, var2, var3, var4, var5, var6);
+   }
+
+   public boolean isValidBonemealTarget(BlockGetter var1, BlockPos var2, BlockState var3, boolean var4) {
+      BlockState var5 = var1.getBlockState(var2.above());
+      return var5.isAir() || var5.getFluidState().is(FluidTags.WATER);
+   }
+
+   public boolean isBonemealSuccess(Level var1, Random var2, BlockPos var3, BlockState var4) {
+      return true;
+   }
+
+   public void performBonemeal(ServerLevel var1, Random var2, BlockPos var3, BlockState var4) {
+      BlockPos var5 = var3.above();
+      if (var1.isInWorldBounds(var5)) {
+         BlockState var6 = var1.getBlockState(var5);
+         Fluid var7 = var6.getFluidState().getType();
+         boolean var8;
+         if (!var6.isAir() && var7 != Fluids.FLOWING_WATER) {
+            if (var7 != Fluids.WATER) {
+               return;
+            }
+
+            var8 = true;
+         } else {
+            var8 = false;
+         }
+
+         var1.setBlock(var5, (BlockState)((BlockState)Blocks.BIG_DRIPLEAF.defaultBlockState().setValue(FACING, var4.getValue(FACING))).setValue(WATERLOGGED, var8), 2);
+         var1.setBlock(var3, (BlockState)((BlockState)Blocks.BIG_DRIPLEAF_STEM.defaultBlockState().setValue(FACING, var4.getValue(FACING))).setValue(WATERLOGGED, var4.getValue(WATERLOGGED)), 2);
+      }
+   }
+
+   public void entityInside(BlockState var1, Level var2, BlockPos var3, Entity var4) {
+      if (!var2.isClientSide) {
+         if (var1.getValue(TILT) == Tilt.NONE && canEntityTilt(var3, var4, true)) {
+            this.setTiltAndScheduleTick(var1, var2, var3, Tilt.UNSTABLE, (SoundEvent)null);
+         }
+
+      }
+   }
+
+   public void tick(BlockState var1, ServerLevel var2, BlockPos var3, Random var4) {
+      Tilt var5 = (Tilt)var1.getValue(TILT);
+      if (var5 == Tilt.UNSTABLE) {
+         if (isAnyEntityTouching(var2, var3, true)) {
+            this.setTiltAndScheduleTick(var1, var2, var3, Tilt.PARTIAL, SoundEvents.BIG_DRIPLEAF_TILT_DOWN);
+         } else {
+            this.resetTilt(var1, var2, var3);
+         }
+      } else if (var5 == Tilt.PARTIAL) {
+         if (isAnyEntityTouching(var2, var3, false)) {
+            this.setTiltAndScheduleTick(var1, var2, var3, Tilt.FULL, SoundEvents.BIG_DRIPLEAF_TILT_DOWN);
+         } else {
+            this.setTiltAndScheduleTick(var1, var2, var3, Tilt.UNSTABLE, SoundEvents.BIG_DRIPLEAF_TILT_UP);
+         }
+      } else if (var5 == Tilt.FULL) {
+         this.resetTilt(var1, var2, var3);
+      }
+
+   }
+
+   private void playTiltSound(Level var1, BlockPos var2, SoundEvent var3) {
+      float var4 = Mth.randomBetween(var1.random, 0.8F, 1.2F);
+      var1.playSound((Player)null, (BlockPos)var2, var3, SoundSource.BLOCKS, 1.0F, var4);
+   }
+
+   private static boolean isAnyEntityTouching(Level var0, BlockPos var1, boolean var2) {
+      Predicate var3 = EntitySelector.NO_SPECTATORS.and((var2x) -> {
+         return canEntityTilt(var1, var2x, var2);
+      });
+      return !var0.getEntities((Entity)null, ENTITY_DETECTION_SHAPE.move(var1), var3).isEmpty();
+   }
+
+   private static boolean canEntityTilt(BlockPos var0, Entity var1, boolean var2) {
+      return var2 && var1.isSteppingCarefully() ? false : isEntityAbove(var0, var1);
+   }
+
+   private static boolean isEntityAbove(BlockPos var0, Entity var1) {
+      return var1.position().y > (double)((float)var0.getY() + 0.6875F);
+   }
+
+   private void setTiltAndScheduleTick(BlockState var1, Level var2, BlockPos var3, Tilt var4, @Nullable SoundEvent var5) {
+      this.setTilt(var1, var2, var3, var4);
+      if (var5 != null) {
+         this.playTiltSound(var2, var3, var5);
+      }
+
+      int var6 = DELAY_UNTIL_NEXT_TILT_STATE.getInt(var4);
+      if (var6 != -1) {
+         var2.getBlockTicks().scheduleTick(var3, this, var6);
+      }
+
+   }
+
+   private void resetTilt(BlockState var1, Level var2, BlockPos var3) {
+      this.setTilt(var1, var2, var3, Tilt.NONE);
+      this.playTiltSound(var2, var3, SoundEvents.BIG_DRIPLEAF_TILT_UP);
+   }
+
+   private void setTilt(BlockState var1, Level var2, BlockPos var3, Tilt var4) {
+      var2.setBlock(var3, (BlockState)var1.setValue(TILT, var4), 2);
+      if (var4.causesVibration()) {
+         var2.gameEvent(GameEvent.BLOCK_CHANGE, var3);
+      }
+
+   }
+
+   public VoxelShape getCollisionShape(BlockState var1, BlockGetter var2, BlockPos var3, CollisionContext var4) {
+      return getLeafShape(var1);
+   }
+
+   public VoxelShape getShape(BlockState var1, BlockGetter var2, BlockPos var3, CollisionContext var4) {
+      return (VoxelShape)this.shapesCache.get(var1);
+   }
+
+   public BlockState getStateForPlacement(BlockPlaceContext var1) {
+      FluidState var2 = var1.getLevel().getFluidState(var1.getClickedPos());
+      return (BlockState)((BlockState)this.defaultBlockState().setValue(WATERLOGGED, var2.isSourceOfType(Fluids.WATER))).setValue(FACING, var1.getHorizontalDirection().getOpposite());
+   }
+
+   protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> var1) {
+      var1.add(WATERLOGGED, FACING, TILT);
+   }
+
+   static {
+      WATERLOGGED = BlockStateProperties.WATERLOGGED;
+      TILT = BlockStateProperties.TILT;
+      DELAY_UNTIL_NEXT_TILT_STATE = (Object2IntMap)Util.make(new Object2IntArrayMap(), (var0) -> {
+         var0.defaultReturnValue(-1);
+         var0.put(Tilt.UNSTABLE, 20);
+         var0.put(Tilt.PARTIAL, 10);
+         var0.put(Tilt.FULL, 100);
+      });
+      ENTITY_DETECTION_SHAPE = Block.box(0.0D, 11.0D, 0.0D, 16.0D, 16.0D, 16.0D).bounds();
+      LEAF_SHAPES = ImmutableMap.of(Tilt.NONE, Block.box(0.0D, 11.0D, 0.0D, 16.0D, 15.0D, 16.0D), Tilt.UNSTABLE, Block.box(0.0D, 11.0D, 0.0D, 16.0D, 15.0D, 16.0D), Tilt.PARTIAL, Block.box(0.0D, 11.0D, 0.0D, 16.0D, 13.0D, 16.0D), Tilt.FULL, Shapes.empty());
+      STEM_SHAPES = ImmutableMap.of(Direction.NORTH, Block.box(5.0D, 0.0D, 8.0D, 11.0D, 11.0D, 14.0D), Direction.SOUTH, Block.box(5.0D, 0.0D, 2.0D, 11.0D, 11.0D, 8.0D), Direction.EAST, Block.box(2.0D, 0.0D, 5.0D, 8.0D, 11.0D, 11.0D), Direction.WEST, Block.box(8.0D, 0.0D, 5.0D, 14.0D, 11.0D, 11.0D));
+   }
+}
