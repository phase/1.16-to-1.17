--- net/minecraft/world/level/block/RedStoneWireBlock.java
+++ net/minecraft/world/level/block/RedStoneWireBlock.java
@@ -6,13 +6,16 @@
 import com.google.common.collect.UnmodifiableIterator;
 import com.mojang.math.Vector3f;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
+import java.util.Random;
 import javax.annotation.Nullable;
+import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
+import net.minecraft.core.particles.DustParticleOptions;
 import net.minecraft.util.Mth;
 import net.minecraft.world.InteractionHand;
 import net.minecraft.world.InteractionResult;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.context.BlockPlaceContext;
@@ -27,10 +30,11 @@
 import net.minecraft.world.level.block.state.properties.EnumProperty;
 import net.minecraft.world.level.block.state.properties.IntegerProperty;
 import net.minecraft.world.level.block.state.properties.Property;
 import net.minecraft.world.level.block.state.properties.RedstoneSide;
 import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
 
 public class RedStoneWireBlock extends Block {
@@ -38,15 +42,21 @@
    public static final EnumProperty<RedstoneSide> EAST;
    public static final EnumProperty<RedstoneSide> SOUTH;
    public static final EnumProperty<RedstoneSide> WEST;
    public static final IntegerProperty POWER;
    public static final Map<Direction, EnumProperty<RedstoneSide>> PROPERTY_BY_DIRECTION;
+   protected static final int H = 1;
+   protected static final int W = 3;
+   protected static final int E = 13;
+   protected static final int N = 3;
+   protected static final int S = 13;
    private static final VoxelShape SHAPE_DOT;
    private static final Map<Direction, VoxelShape> SHAPES_FLOOR;
    private static final Map<Direction, VoxelShape> SHAPES_UP;
-   private final Map<BlockState, VoxelShape> SHAPES_CACHE = Maps.newHashMap();
-   private static final Vector3f[] COLORS;
+   private static final Map<BlockState, VoxelShape> SHAPES_CACHE;
+   private static final Vec3[] COLORS;
+   private static final float PARTICLE_DENSITY = 0.2F;
    private final BlockState crossState;
    private boolean shouldSignal = true;
 
    public RedStoneWireBlock(BlockBehaviour.Properties var1) {
       super(var1);
@@ -55,11 +65,11 @@
       UnmodifiableIterator var2 = this.getStateDefinition().getPossibleStates().iterator();
 
       while(var2.hasNext()) {
          BlockState var3 = (BlockState)var2.next();
          if ((Integer)var3.getValue(POWER) == 0) {
-            this.SHAPES_CACHE.put(var3, this.calculateShape(var3));
+            SHAPES_CACHE.put(var3, this.calculateShape(var3));
          }
       }
 
    }
 
@@ -79,11 +89,11 @@
 
       return var2;
    }
 
    public VoxelShape getShape(BlockState var1, BlockGetter var2, BlockPos var3, CollisionContext var4) {
-      return (VoxelShape)this.SHAPES_CACHE.get(var1.setValue(POWER, 0));
+      return (VoxelShape)SHAPES_CACHE.get(var1.setValue(POWER, 0));
    }
 
    public BlockState getStateForPlacement(BlockPlaceContext var1) {
       return this.getConnectionState(var1.getLevel(), this.crossState, var1.getClickedPos());
    }
@@ -159,20 +169,20 @@
       Iterator var7 = Direction.Plane.HORIZONTAL.iterator();
 
       while(var7.hasNext()) {
          Direction var8 = (Direction)var7.next();
          RedstoneSide var9 = (RedstoneSide)var1.getValue((Property)PROPERTY_BY_DIRECTION.get(var8));
-         if (var9 != RedstoneSide.NONE && !var2.getBlockState(var6.setWithOffset(var3, var8)).is(this)) {
+         if (var9 != RedstoneSide.NONE && !var2.getBlockState(var6.setWithOffset(var3, (Direction)var8)).is(this)) {
             var6.move(Direction.DOWN);
             BlockState var10 = var2.getBlockState(var6);
             if (!var10.is(Blocks.OBSERVER)) {
                BlockPos var11 = var6.relative(var8.getOpposite());
                BlockState var12 = var10.updateShape(var8.getOpposite(), var2.getBlockState(var11), var2, var6, var11);
                updateOrDestroy(var10, var12, var2, var6, var4, var5);
             }
 
-            var6.setWithOffset(var3, var8).move(Direction.UP);
+            var6.setWithOffset(var3, (Direction)var8).move(Direction.UP);
             BlockState var14 = var2.getBlockState(var6);
             if (!var14.is(Blocks.OBSERVER)) {
                BlockPos var15 = var6.relative(var8.getOpposite());
                BlockState var13 = var14.updateShape(var8.getOpposite(), var2.getBlockState(var15), var2, var6, var15);
                updateOrDestroy(var14, var13, var2, var6, var4, var5);
@@ -390,10 +400,50 @@
 
    public boolean isSignalSource(BlockState var1) {
       return this.shouldSignal;
    }
 
+   public static int getColorForPower(int var0) {
+      Vec3 var1 = COLORS[var0];
+      return Mth.color((float)var1.x(), (float)var1.y(), (float)var1.z());
+   }
+
+   private void spawnParticlesAlongLine(Level var1, Random var2, BlockPos var3, Vec3 var4, Direction var5, Direction var6, float var7, float var8) {
+      float var9 = var8 - var7;
+      if (var2.nextFloat() < 0.2F * var9) {
+         float var10 = 0.4375F;
+         float var11 = var7 + var9 * var2.nextFloat();
+         double var12 = 0.5D + (double)(0.4375F * (float)var5.getStepX()) + (double)(var11 * (float)var6.getStepX());
+         double var14 = 0.5D + (double)(0.4375F * (float)var5.getStepY()) + (double)(var11 * (float)var6.getStepY());
+         double var16 = 0.5D + (double)(0.4375F * (float)var5.getStepZ()) + (double)(var11 * (float)var6.getStepZ());
+         var1.addParticle(new DustParticleOptions(new Vector3f(var4), 1.0F), (double)var3.getX() + var12, (double)var3.getY() + var14, (double)var3.getZ() + var16, 0.0D, 0.0D, 0.0D);
+      }
+   }
+
+   public void animateTick(BlockState var1, Level var2, BlockPos var3, Random var4) {
+      int var5 = (Integer)var1.getValue(POWER);
+      if (var5 != 0) {
+         Iterator var6 = Direction.Plane.HORIZONTAL.iterator();
+
+         while(var6.hasNext()) {
+            Direction var7 = (Direction)var6.next();
+            RedstoneSide var8 = (RedstoneSide)var1.getValue((Property)PROPERTY_BY_DIRECTION.get(var7));
+            switch(var8) {
+            case UP:
+               this.spawnParticlesAlongLine(var2, var4, var3, COLORS[var5], var7, Direction.UP, -0.5F, 0.5F);
+            case SIDE:
+               this.spawnParticlesAlongLine(var2, var4, var3, COLORS[var5], Direction.DOWN, var7, 0.0F, 0.5F);
+               break;
+            case NONE:
+            default:
+               this.spawnParticlesAlongLine(var2, var4, var3, COLORS[var5], Direction.DOWN, var7, 0.0F, 0.3F);
+            }
+         }
+
+      }
+   }
+
    public BlockState rotate(BlockState var1, Rotation var2) {
       switch(var2) {
       case CLOCKWISE_180:
          return (BlockState)((BlockState)((BlockState)((BlockState)var1.setValue(NORTH, var1.getValue(SOUTH))).setValue(EAST, var1.getValue(WEST))).setValue(SOUTH, var1.getValue(NORTH))).setValue(WEST, var1.getValue(EAST));
       case COUNTERCLOCKWISE_90:
@@ -419,11 +469,11 @@
    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> var1) {
       var1.add(NORTH, EAST, SOUTH, WEST, POWER);
    }
 
    public InteractionResult use(BlockState var1, Level var2, BlockPos var3, Player var4, InteractionHand var5, BlockHitResult var6) {
-      if (!var4.abilities.mayBuild) {
+      if (!var4.getAbilities().mayBuild) {
          return InteractionResult.PASS;
       } else {
          if (isCross(var1) || isDot(var1)) {
             BlockState var7 = isCross(var1) ? this.defaultBlockState() : this.crossState;
             var7 = (BlockState)var7.setValue(POWER, var1.getValue(POWER));
@@ -460,17 +510,18 @@
       POWER = BlockStateProperties.POWER;
       PROPERTY_BY_DIRECTION = Maps.newEnumMap((Map)ImmutableMap.of(Direction.NORTH, NORTH, Direction.EAST, EAST, Direction.SOUTH, SOUTH, Direction.WEST, WEST));
       SHAPE_DOT = Block.box(3.0D, 0.0D, 3.0D, 13.0D, 1.0D, 13.0D);
       SHAPES_FLOOR = Maps.newEnumMap((Map)ImmutableMap.of(Direction.NORTH, Block.box(3.0D, 0.0D, 0.0D, 13.0D, 1.0D, 13.0D), Direction.SOUTH, Block.box(3.0D, 0.0D, 3.0D, 13.0D, 1.0D, 16.0D), Direction.EAST, Block.box(3.0D, 0.0D, 3.0D, 16.0D, 1.0D, 13.0D), Direction.WEST, Block.box(0.0D, 0.0D, 3.0D, 13.0D, 1.0D, 13.0D)));
       SHAPES_UP = Maps.newEnumMap((Map)ImmutableMap.of(Direction.NORTH, Shapes.or((VoxelShape)SHAPES_FLOOR.get(Direction.NORTH), Block.box(3.0D, 0.0D, 0.0D, 13.0D, 16.0D, 1.0D)), Direction.SOUTH, Shapes.or((VoxelShape)SHAPES_FLOOR.get(Direction.SOUTH), Block.box(3.0D, 0.0D, 15.0D, 13.0D, 16.0D, 16.0D)), Direction.EAST, Shapes.or((VoxelShape)SHAPES_FLOOR.get(Direction.EAST), Block.box(15.0D, 0.0D, 3.0D, 16.0D, 16.0D, 13.0D)), Direction.WEST, Shapes.or((VoxelShape)SHAPES_FLOOR.get(Direction.WEST), Block.box(0.0D, 0.0D, 3.0D, 1.0D, 16.0D, 13.0D))));
-      COLORS = new Vector3f[16];
+      SHAPES_CACHE = Maps.newHashMap();
+      COLORS = (Vec3[])Util.make(new Vec3[16], (var0) -> {
+         for(int var1 = 0; var1 <= 15; ++var1) {
+            float var2 = (float)var1 / 15.0F;
+            float var3 = var2 * 0.6F + (var2 > 0.0F ? 0.4F : 0.3F);
+            float var4 = Mth.clamp(var2 * var2 * 0.7F - 0.5F, 0.0F, 1.0F);
+            float var5 = Mth.clamp(var2 * var2 * 0.6F - 0.7F, 0.0F, 1.0F);
+            var0[var1] = new Vec3((double)var3, (double)var4, (double)var5);
+         }
 
-      for(int var0 = 0; var0 <= 15; ++var0) {
-         float var1 = (float)var0 / 15.0F;
-         float var2 = var1 * 0.6F + (var1 > 0.0F ? 0.4F : 0.3F);
-         float var3 = Mth.clamp(var1 * var1 * 0.7F - 0.5F, 0.0F, 1.0F);
-         float var4 = Mth.clamp(var1 * var1 * 0.6F - 0.7F, 0.0F, 1.0F);
-         COLORS[var0] = new Vector3f(var2, var3, var4);
-      }
-
+      });
    }
 }
