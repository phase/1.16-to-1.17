--- net/minecraft/server/level/ChunkMap.java
+++ net/minecraft/server/level/ChunkMap.java
@@ -20,11 +20,11 @@
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import java.io.File;
 import java.io.IOException;
 import java.io.Writer;
 import java.util.ArrayList;
-import java.util.Collection;
+import java.util.BitSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.Queue;
@@ -54,11 +54,11 @@
 import net.minecraft.network.protocol.game.ClientboundSetChunkCacheCenterPacket;
 import net.minecraft.network.protocol.game.ClientboundSetEntityLinkPacket;
 import net.minecraft.network.protocol.game.ClientboundSetPassengersPacket;
 import net.minecraft.network.protocol.game.DebugPackets;
 import net.minecraft.server.level.progress.ChunkProgressListener;
-import net.minecraft.util.ClassInstanceMultiMap;
+import net.minecraft.server.network.ServerPlayerConnection;
 import net.minecraft.util.CsvOutput;
 import net.minecraft.util.Mth;
 import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.util.thread.BlockableEventLoop;
 import net.minecraft.util.thread.ProcessorHandle;
@@ -66,11 +66,10 @@
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.Mob;
 import net.minecraft.world.entity.ai.village.poi.PoiManager;
 import net.minecraft.world.entity.boss.EnderDragonPart;
-import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.GameRules;
 import net.minecraft.world.level.chunk.ChunkAccess;
 import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.chunk.ChunkStatus;
@@ -79,10 +78,11 @@
 import net.minecraft.world.level.chunk.LightChunkGetter;
 import net.minecraft.world.level.chunk.ProtoChunk;
 import net.minecraft.world.level.chunk.UpgradeData;
 import net.minecraft.world.level.chunk.storage.ChunkSerializer;
 import net.minecraft.world.level.chunk.storage.ChunkStorage;
+import net.minecraft.world.level.entity.ChunkStatusUpdateListener;
 import net.minecraft.world.level.levelgen.structure.StructureStart;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureManager;
 import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelStorageSource;
 import net.minecraft.world.phys.Vec3;
@@ -107,22 +107,23 @@
    private boolean modified;
    private final ChunkTaskPriorityQueueSorter queueSorter;
    private final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> worldgenMailbox;
    private final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> mainThreadMailbox;
    private final ChunkProgressListener progressListener;
+   private final ChunkStatusUpdateListener chunkStatusListener;
    private final ChunkMap.DistanceManager distanceManager;
    private final AtomicInteger tickingGenerated;
    private final StructureManager structureManager;
    private final File storageFolder;
    private final PlayerMap playerMap;
    private final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap;
    private final Long2ByteMap chunkTypeCache;
    private final Queue<Runnable> unloadQueue;
    private int viewDistance;
 
-   public ChunkMap(ServerLevel var1, LevelStorageSource.LevelStorageAccess var2, DataFixer var3, StructureManager var4, Executor var5, BlockableEventLoop<Runnable> var6, LightChunkGetter var7, ChunkGenerator var8, ChunkProgressListener var9, Supplier<DimensionDataStorage> var10, int var11, boolean var12) {
-      super(new File(var2.getDimensionPath(var1.dimension()), "region"), var3, var12);
+   public ChunkMap(ServerLevel var1, LevelStorageSource.LevelStorageAccess var2, DataFixer var3, StructureManager var4, Executor var5, BlockableEventLoop<Runnable> var6, LightChunkGetter var7, ChunkGenerator var8, ChunkProgressListener var9, ChunkStatusUpdateListener var10, Supplier<DimensionDataStorage> var11, int var12, boolean var13) {
+      super(new File(var2.getDimensionPath(var1.dimension()), "region"), var3, var13);
       this.visibleChunkMap = this.updatingChunkMap.clone();
       this.pendingUnloads = new Long2ObjectLinkedOpenHashMap();
       this.entitiesInLevel = new LongOpenHashSet();
       this.toDrop = new LongOpenHashSet();
       this.tickingGenerated = new AtomicInteger();
@@ -133,28 +134,29 @@
       this.structureManager = var4;
       this.storageFolder = var2.getDimensionPath(var1.dimension());
       this.level = var1;
       this.generator = var8;
       this.mainThreadExecutor = var6;
-      ProcessorMailbox var13 = ProcessorMailbox.create(var5, "worldgen");
+      ProcessorMailbox var14 = ProcessorMailbox.create(var5, "worldgen");
       var6.getClass();
-      ProcessorHandle var14 = ProcessorHandle.of("main", var6::tell);
+      ProcessorHandle var15 = ProcessorHandle.of("main", var6::tell);
       this.progressListener = var9;
-      ProcessorMailbox var15 = ProcessorMailbox.create(var5, "light");
-      this.queueSorter = new ChunkTaskPriorityQueueSorter(ImmutableList.of(var13, var14, var15), var5, Integer.MAX_VALUE);
-      this.worldgenMailbox = this.queueSorter.getProcessor(var13, false);
-      this.mainThreadMailbox = this.queueSorter.getProcessor(var14, false);
-      this.lightEngine = new ThreadedLevelLightEngine(var7, this, this.level.dimensionType().hasSkyLight(), var15, this.queueSorter.getProcessor(var15, false));
+      this.chunkStatusListener = var10;
+      ProcessorMailbox var16 = ProcessorMailbox.create(var5, "light");
+      this.queueSorter = new ChunkTaskPriorityQueueSorter(ImmutableList.of(var14, var15, var16), var5, Integer.MAX_VALUE);
+      this.worldgenMailbox = this.queueSorter.getProcessor(var14, false);
+      this.mainThreadMailbox = this.queueSorter.getProcessor(var15, false);
+      this.lightEngine = new ThreadedLevelLightEngine(var7, this, this.level.dimensionType().hasSkyLight(), var16, this.queueSorter.getProcessor(var16, false));
       this.distanceManager = new ChunkMap.DistanceManager(var5, var6);
-      this.overworldDataStorage = var10;
-      this.poiManager = new PoiManager(new File(this.storageFolder, "poi"), var3, var12);
-      this.setViewDistance(var11);
+      this.overworldDataStorage = var11;
+      this.poiManager = new PoiManager(new File(this.storageFolder, "poi"), var3, var13, var1);
+      this.setViewDistance(var12);
    }
 
    private static double euclideanDistanceSquared(ChunkPos var0, Entity var1) {
-      double var2 = (double)(var0.x * 16 + 8);
-      double var4 = (double)(var0.z * 16 + 8);
+      double var2 = (double)SectionPos.sectionToBlockCoord(var0.x, 8);
+      double var4 = (double)SectionPos.sectionToBlockCoord(var0.z, 8);
       double var6 = var2 - var1.getX();
       double var8 = var4 - var1.getZ();
       return var6 * var6 + var8 * var8;
    }
 
@@ -164,12 +166,12 @@
       if (var2) {
          SectionPos var5 = var1.getLastSectionPos();
          var3 = var5.x();
          var4 = var5.z();
       } else {
-         var3 = Mth.floor(var1.getX() / 16.0D);
-         var4 = Mth.floor(var1.getZ() / 16.0D);
+         var3 = SectionPos.blockToSectionCoord(var1.getBlockX());
+         var4 = SectionPos.blockToSectionCoord(var1.getBlockZ());
       }
 
       return checkerboardDistance(var0, var3, var4);
    }
 
@@ -212,11 +214,11 @@
             long var11 = var10.toLong();
             ChunkHolder var13 = this.getUpdatingChunkIfPresent(var11);
             if (var13 == null) {
                return CompletableFuture.completedFuture(Either.right(new ChunkHolder.ChunkLoadingFailure() {
                   public String toString() {
-                     return "Unloaded " + var10.toString();
+                     return "Unloaded " + var10;
                   }
                }));
             }
 
             ChunkStatus var14 = (ChunkStatus)var3.apply(var9);
@@ -234,11 +236,11 @@
             final Either var8 = (Either)var7.next();
             Optional var9 = var8.left();
             if (!var9.isPresent()) {
                return Either.right(new ChunkHolder.ChunkLoadingFailure() {
                   public String toString() {
-                     return "Unloaded " + new ChunkPos(var1 + var6 % (var2 * 2 + 1), var3 + var6 / (var2 * 2 + 1)) + " " + ((ChunkHolder.ChunkLoadingFailure)var8.right().get()).toString();
+                     return "Unloaded " + new ChunkPos(var1 + var6 % (var2 * 2 + 1), var3 + var6 / (var2 * 2 + 1)) + " " + var8.right().get();
                   }
                });
             }
 
             var5x.add(var9.get());
@@ -246,11 +248,11 @@
 
          return Either.left(var5x);
       });
    }
 
-   public CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> getEntityTickingRangeFuture(ChunkPos var1) {
+   public CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> prepareEntityTickingChunk(ChunkPos var1) {
       return this.getChunkRangeFuture(var1, 2, (var0) -> {
          return ChunkStatus.FULL;
       }).thenApplyAsync((var0) -> {
          return var0.mapLeft((var0x) -> {
             return (LevelChunk)var0x.get(var0x.size() / 2);
@@ -278,11 +280,11 @@
          if (var3 <= MAX_CHUNK_DISTANCE && var4 == null) {
             var4 = (ChunkHolder)this.pendingUnloads.remove(var1);
             if (var4 != null) {
                var4.setTicketLevel(var3);
             } else {
-               var4 = new ChunkHolder(new ChunkPos(var1), var3, this.lightEngine, this.queueSorter, this);
+               var4 = new ChunkHolder(new ChunkPos(var1), var3, this.level, this.lightEngine, this.queueSorter, this);
             }
 
             this.updatingChunkMap.put(var1, var4);
             this.modified = true;
          }
@@ -401,11 +403,11 @@
       };
       Queue var10002 = this.unloadQueue;
       var10002.getClass();
       var4.thenAcceptAsync(var10001, var10002::add).whenComplete((var1x, var2) -> {
          if (var2 != null) {
-            LOGGER.error("Failed to save chunk " + var3.getPos(), var2);
+            LOGGER.error((String)"Failed to save chunk {}", (Object)var3.getPos(), (Object)var2);
          }
 
       });
    }
 
@@ -434,19 +436,13 @@
                   this.distanceManager.addTicket(TicketType.LIGHT, var3, 33 + ChunkStatus.getDistance(ChunkStatus.FEATURES), var3);
                }
 
                ChunkAccess var6 = (ChunkAccess)var5.get();
                if (var6.getStatus().isOrAfter(var2)) {
-                  CompletableFuture var7;
-                  if (var2 == ChunkStatus.LIGHT) {
-                     var7 = this.scheduleChunkGeneration(var1, var2);
-                  } else {
-                     var7 = var2.load(this.level, this.structureManager, this.lightEngine, (var2x) -> {
-                        return this.protoChunkToFullChunk(var1);
-                     }, var6);
-                  }
-
+                  CompletableFuture var7 = var2.load(this.level, this.structureManager, this.lightEngine, (var2x) -> {
+                     return this.protoChunkToFullChunk(var1);
+                  }, var6);
                   this.progressListener.onStatusChange(var3, var2);
                   return var7;
                } else {
                   return this.scheduleChunkGeneration(var1, var2);
                }
@@ -462,11 +458,10 @@
             CompoundTag var2 = this.readChunk(var1);
             if (var2 != null) {
                boolean var7 = var2.contains("Level", 10) && var2.getCompound("Level").contains("Status", 8);
                if (var7) {
                   ProtoChunk var4 = ChunkSerializer.read(this.level, this.structureManager, this.poiManager, var1, var2);
-                  var4.setLastSaveTime(this.level.getGameTime());
                   this.markPosition(var1, var4.getStatus().getChunkType());
                   return Either.left(var4);
                }
 
                LOGGER.error((String)"Chunk file at {} is missing level data, skipping", (Object)var1);
@@ -482,11 +477,11 @@
          } catch (Exception var6) {
             LOGGER.error((String)"Couldn't load chunk {}", (Object)var1, (Object)var6);
          }
 
          this.markPositionReplaceable(var1);
-         return Either.left(new ProtoChunk(var1, UpgradeData.EMPTY));
+         return Either.left(new ProtoChunk(var1, UpgradeData.EMPTY, this.level));
       }, this.mainThreadExecutor);
    }
 
    private void markPositionReplaceable(ChunkPos var1) {
       this.chunkTypeCache.put(var1.toLong(), (byte)-1);
@@ -540,73 +535,60 @@
    private ChunkStatus getDependencyStatus(ChunkStatus var1, int var2) {
       ChunkStatus var3;
       if (var2 == 0) {
          var3 = var1.getParent();
       } else {
-         var3 = ChunkStatus.getStatus(ChunkStatus.getDistance(var1) + var2);
+         var3 = ChunkStatus.getStatusAroundFullChunk(ChunkStatus.getDistance(var1) + var2);
       }
 
       return var3;
    }
 
+   private static void postLoadProtoChunk(ServerLevel var0, List<CompoundTag> var1) {
+      if (!var1.isEmpty()) {
+         var0.addWorldGenChunkEntities(EntityType.loadEntitiesRecursive(var1, var0));
+      }
+
+   }
+
    private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> protoChunkToFullChunk(ChunkHolder var1) {
       CompletableFuture var2 = var1.getFutureIfPresentUnchecked(ChunkStatus.FULL.getParent());
       return var2.thenApplyAsync((var2x) -> {
          ChunkStatus var3 = ChunkHolder.getStatus(var1.getTicketLevel());
          return !var3.isOrAfter(ChunkStatus.FULL) ? ChunkHolder.UNLOADED_CHUNK : var2x.mapLeft((var2) -> {
             ChunkPos var3 = var1.getPos();
-            LevelChunk var4;
-            if (var2 instanceof ImposterProtoChunk) {
-               var4 = ((ImposterProtoChunk)var2).getWrapped();
+            ProtoChunk var4 = (ProtoChunk)var2;
+            LevelChunk var5;
+            if (var4 instanceof ImposterProtoChunk) {
+               var5 = ((ImposterProtoChunk)var4).getWrapped();
             } else {
-               var4 = new LevelChunk(this.level, (ProtoChunk)var2);
-               var1.replaceProtoChunk(new ImposterProtoChunk(var4));
+               var5 = new LevelChunk(this.level, var4, (var2x) -> {
+                  postLoadProtoChunk(this.level, var4.getEntities());
+               });
+               var1.replaceProtoChunk(new ImposterProtoChunk(var5));
             }
 
-            var4.setFullStatus(() -> {
+            var5.setFullStatus(() -> {
                return ChunkHolder.getFullChunkStatus(var1.getTicketLevel());
             });
-            var4.runPostLoad();
+            var5.runPostLoad();
             if (this.entitiesInLevel.add(var3.toLong())) {
-               var4.setLoaded(true);
-               this.level.addAllPendingBlockEntities(var4.getBlockEntities().values());
-               ArrayList var5 = null;
-               ClassInstanceMultiMap[] var6 = var4.getEntitySections();
-               int var7 = var6.length;
-
-               for(int var8 = 0; var8 < var7; ++var8) {
-                  ClassInstanceMultiMap var9 = var6[var8];
-                  Iterator var10 = var9.iterator();
-
-                  while(var10.hasNext()) {
-                     Entity var11 = (Entity)var10.next();
-                     if (!(var11 instanceof Player) && !this.level.loadFromChunk(var11)) {
-                        if (var5 == null) {
-                           var5 = Lists.newArrayList((Object[])(var11));
-                        } else {
-                           var5.add(var11);
-                        }
-                     }
-                  }
-               }
-
-               if (var5 != null) {
-                  var5.forEach(var4::removeEntity);
-               }
+               var5.setLoaded(true);
+               var5.registerAllBlockEntitiesAfterLevelLoad();
             }
 
-            return var4;
+            return var5;
          });
       }, (var2x) -> {
          ProcessorHandle var10000 = this.mainThreadMailbox;
          long var10002 = var1.getPos().toLong();
          var1.getClass();
          var10000.tell(ChunkTaskPriorityQueueSorter.message(var2x, var10002, var1::getTicketLevel));
       });
    }
 
-   public CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> postProcess(ChunkHolder var1) {
+   public CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> prepareTickingChunk(ChunkHolder var1) {
       ChunkPos var2 = var1.getPos();
       CompletableFuture var3 = this.getChunkRangeFuture(var2, 1, (var0) -> {
          return ChunkStatus.FULL;
       });
       CompletableFuture var4 = var3.thenApplyAsync((var0) -> {
@@ -617,28 +599,27 @@
          });
       }, (var2x) -> {
          this.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(var1, var2x));
       });
       var4.thenAcceptAsync((var2x) -> {
-         var2x.mapLeft((var2xx) -> {
+         var2x.ifLeft((var2xx) -> {
             this.tickingGenerated.getAndIncrement();
             Packet[] var3 = new Packet[2];
             this.getPlayers(var2, false).forEach((var3x) -> {
                this.playerLoadedChunk(var3x, var3, var2xx);
             });
-            return Either.left(var2xx);
          });
       }, (var2x) -> {
          this.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(var1, var2x));
       });
       return var4;
    }
 
-   public CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> unpackTicks(ChunkHolder var1) {
-      return var1.getOrScheduleFuture(ChunkStatus.FULL, this).thenApplyAsync((var0) -> {
+   public CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> prepareAccessibleChunk(ChunkHolder var1) {
+      return this.getChunkRangeFuture(var1.getPos(), 1, ChunkStatus::getStatusAroundFullChunk).thenApplyAsync((var0) -> {
          return var0.mapLeft((var0x) -> {
-            LevelChunk var1 = (LevelChunk)var0x;
+            LevelChunk var1 = (LevelChunk)var0x.get(var0x.size() / 2);
             var1.unpackTicks();
             return var1;
          });
       }, (var2) -> {
          this.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(var1, var2));
@@ -652,11 +633,10 @@
    private boolean save(ChunkAccess var1) {
       this.poiManager.flush(var1.getPos());
       if (!var1.isUnsaved()) {
          return false;
       } else {
-         var1.setLastSaveTime(this.level.getGameTime());
          var1.setUnsaved(false);
          ChunkPos var2 = var1.getPos();
 
          try {
             ChunkStatus var3 = var1.getStatus();
@@ -751,20 +731,20 @@
 
    public int size() {
       return this.visibleChunkMap.size();
    }
 
-   protected ChunkMap.DistanceManager getDistanceManager() {
+   protected net.minecraft.server.level.DistanceManager getDistanceManager() {
       return this.distanceManager;
    }
 
    protected Iterable<ChunkHolder> getChunks() {
       return Iterables.unmodifiableIterable((Iterable)this.visibleChunkMap.values());
    }
 
    void dumpChunks(Writer var1) throws IOException {
-      CsvOutput var2 = CsvOutput.builder().addColumn("x").addColumn("z").addColumn("level").addColumn("in_memory").addColumn("status").addColumn("full_status").addColumn("accessible_ready").addColumn("ticking_ready").addColumn("entity_ticking_ready").addColumn("ticket").addColumn("spawning").addColumn("entity_count").addColumn("block_entity_count").build(var1);
+      CsvOutput var2 = CsvOutput.builder().addColumn("x").addColumn("z").addColumn("level").addColumn("in_memory").addColumn("status").addColumn("full_status").addColumn("accessible_ready").addColumn("ticking_ready").addColumn("entity_ticking_ready").addColumn("ticket").addColumn("spawning").addColumn("block_entity_count").build(var1);
       ObjectBidirectionalIterator var3 = this.visibleChunkMap.long2ObjectEntrySet().iterator();
 
       while(var3.hasNext()) {
          Long2ObjectMap.Entry var4 = (Long2ObjectMap.Entry)var3.next();
          ChunkPos var5 = new ChunkPos(var4.getLongKey());
@@ -772,12 +752,10 @@
          Optional var7 = Optional.ofNullable(var6.getLastAvailable());
          Optional var8 = var7.flatMap((var0) -> {
             return var0 instanceof LevelChunk ? Optional.of((LevelChunk)var0) : Optional.empty();
          });
          var2.writeRow(var5.x, var5.z, var6.getTicketLevel(), var7.isPresent(), var7.map(ChunkAccess::getStatus).orElse((Object)null), var8.map(LevelChunk::getFullStatus).orElse((Object)null), printFuture(var6.getFullChunkFuture()), printFuture(var6.getTickingChunkFuture()), printFuture(var6.getEntityTickingChunkFuture()), this.distanceManager.getTicketDebugString(var4.getLongKey()), !this.noPlayersCloseForSpawning(var5), var8.map((var0) -> {
-            return Stream.of(var0.getEntitySections()).mapToInt(ClassInstanceMultiMap::size).sum();
-         }).orElse(0), var8.map((var0) -> {
             return var0.getBlockEntities().size();
          }).orElse(0));
       }
 
    }
@@ -815,12 +793,12 @@
    }
 
    void updatePlayerStatus(ServerPlayer var1, boolean var2) {
       boolean var3 = this.skipPlayer(var1);
       boolean var4 = this.playerMap.ignoredOrUnknown(var1);
-      int var5 = Mth.floor(var1.getX()) >> 4;
-      int var6 = Mth.floor(var1.getZ()) >> 4;
+      int var5 = SectionPos.blockToSectionCoord(var1.getBlockX());
+      int var6 = SectionPos.blockToSectionCoord(var1.getBlockZ());
       if (var2) {
          this.playerMap.addPlayer(ChunkPos.asLong(var5, var6), var1, var3);
          this.updatePlayerPos(var1);
          if (!var3) {
             this.distanceManager.addPlayer(SectionPos.of((Entity)var1), var1);
@@ -859,12 +837,12 @@
          } else {
             var3.updatePlayer(var1);
          }
       }
 
-      int var24 = Mth.floor(var1.getX()) >> 4;
-      int var25 = Mth.floor(var1.getZ()) >> 4;
+      int var24 = SectionPos.blockToSectionCoord(var1.getBlockX());
+      int var25 = SectionPos.blockToSectionCoord(var1.getBlockZ());
       SectionPos var4 = var1.getLastSectionPos();
       SectionPos var5 = SectionPos.of((Entity)var1);
       long var6 = var4.chunk().toLong();
       long var8 = var5.chunk().toLong();
       boolean var10 = this.playerMap.ignored(var1);
@@ -1042,12 +1020,12 @@
 
    }
 
    private void playerLoadedChunk(ServerPlayer var1, Packet<?>[] var2, LevelChunk var3) {
       if (var2[0] == null) {
-         var2[0] = new ClientboundLevelChunkPacket(var3, 65535);
-         var2[1] = new ClientboundLightUpdatePacket(var3.getPos(), this.lightEngine, true);
+         var2[0] = new ClientboundLevelChunkPacket(var3);
+         var2[1] = new ClientboundLightUpdatePacket(var3.getPos(), this.lightEngine, (BitSet)null, (BitSet)null, true);
       }
 
       var1.trackChunk(var3.getPos(), var2[0], var2[1]);
       DebugPackets.sendPoiPacketsForChunk(this.level, var3.getPos());
       ArrayList var4 = Lists.newArrayList();
@@ -1055,11 +1033,11 @@
       ObjectIterator var6 = this.entityMap.values().iterator();
 
       while(var6.hasNext()) {
          ChunkMap.TrackedEntity var7 = (ChunkMap.TrackedEntity)var6.next();
          Entity var8 = var7.entity;
-         if (var8 != var1 && var8.xChunk == var3.getPos().x && var8.zChunk == var3.getPos().z) {
+         if (var8 != var1 && var8.chunkPosition().equals(var3.getPos())) {
             var7.updatePlayer(var1);
             if (var8 instanceof Mob && ((Mob)var8).getLeashHolder() != null) {
                var4.add(var8);
             }
 
@@ -1099,16 +1077,20 @@
       return this.mainThreadExecutor.submit(() -> {
          var1.packTicks(this.level);
       });
    }
 
+   void onFullChunkStatusChange(ChunkPos var1, ChunkHolder.FullChunkStatus var2) {
+      this.chunkStatusListener.onChunkStatusChange(var1, var2);
+   }
+
    class TrackedEntity {
       private final ServerEntity serverEntity;
       private final Entity entity;
       private final int range;
       private SectionPos lastSectionPos;
-      private final Set<ServerPlayer> seenBy = Sets.newHashSet();
+      private final Set<ServerPlayerConnection> seenBy = Sets.newIdentityHashSet();
 
       public TrackedEntity(Entity var2, int var3, int var4, boolean var5) {
          this.serverEntity = new ServerEntity(ChunkMap.this.level, var2, var4, var5, this::broadcast);
          this.entity = var2;
          this.range = var3;
@@ -1129,12 +1111,12 @@
 
       public void broadcast(Packet<?> var1) {
          Iterator var2 = this.seenBy.iterator();
 
          while(var2.hasNext()) {
-            ServerPlayer var3 = (ServerPlayer)var2.next();
-            var3.connection.send(var1);
+            ServerPlayerConnection var3 = (ServerPlayerConnection)var2.next();
+            var3.send(var1);
          }
 
       }
 
       public void broadcastAndSend(Packet<?> var1) {
@@ -1147,18 +1129,18 @@
 
       public void broadcastRemoved() {
          Iterator var1 = this.seenBy.iterator();
 
          while(var1.hasNext()) {
-            ServerPlayer var2 = (ServerPlayer)var1.next();
-            this.serverEntity.removePairing(var2);
+            ServerPlayerConnection var2 = (ServerPlayerConnection)var1.next();
+            this.serverEntity.removePairing(var2.getPlayer());
          }
 
       }
 
       public void removePlayer(ServerPlayer var1) {
-         if (this.seenBy.remove(var1)) {
+         if (this.seenBy.remove(var1.connection)) {
             this.serverEntity.removePairing(var1);
          }
 
       }
 
@@ -1166,23 +1148,14 @@
          if (var1 != this.entity) {
             Vec3 var2 = var1.position().subtract(this.serverEntity.sentPos());
             int var3 = Math.min(this.getEffectiveRange(), (ChunkMap.this.viewDistance - 1) * 16);
             boolean var4 = var2.x >= (double)(-var3) && var2.x <= (double)var3 && var2.z >= (double)(-var3) && var2.z <= (double)var3 && this.entity.broadcastToPlayer(var1);
             if (var4) {
-               boolean var5 = this.entity.forcedLoading;
-               if (!var5) {
-                  ChunkPos var6 = new ChunkPos(this.entity.xChunk, this.entity.zChunk);
-                  ChunkHolder var7 = ChunkMap.this.getVisibleChunkIfPresent(var6.toLong());
-                  if (var7 != null && var7.getTickingChunk() != null) {
-                     var5 = ChunkMap.checkerboardDistance(var6, var1, false) <= ChunkMap.this.viewDistance;
-                  }
-               }
-
-               if (var5 && this.seenBy.add(var1)) {
+               if (this.seenBy.add(var1.connection)) {
                   this.serverEntity.addPairing(var1);
                }
-            } else if (this.seenBy.remove(var1)) {
+            } else if (this.seenBy.remove(var1.connection)) {
                this.serverEntity.removePairing(var1);
             }
 
          }
       }
@@ -1190,23 +1163,22 @@
       private int scaledRange(int var1) {
          return ChunkMap.this.level.getServer().getScaledTrackingDistance(var1);
       }
 
       private int getEffectiveRange() {
-         Collection var1 = this.entity.getIndirectPassengers();
-         int var2 = this.range;
-         Iterator var3 = var1.iterator();
+         int var1 = this.range;
+         Iterator var2 = this.entity.getIndirectPassengers().iterator();
 
-         while(var3.hasNext()) {
-            Entity var4 = (Entity)var3.next();
-            int var5 = var4.getType().clientTrackingRange() * 16;
-            if (var5 > var2) {
-               var2 = var5;
+         while(var2.hasNext()) {
+            Entity var3 = (Entity)var2.next();
+            int var4 = var3.getType().clientTrackingRange() * 16;
+            if (var4 > var1) {
+               var1 = var4;
             }
          }
 
-         return this.scaledRange(var2);
+         return this.scaledRange(var1);
       }
 
       public void updatePlayers(List<ServerPlayer> var1) {
          Iterator var2 = var1.iterator();
 
