--- net/minecraft/server/level/DistanceManager.java
+++ net/minecraft/server/level/DistanceManager.java
@@ -13,10 +13,15 @@
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import it.unimi.dsi.fastutil.objects.ObjectSet;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.util.Iterator;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import javax.annotation.Nullable;
 import net.minecraft.core.SectionPos;
@@ -27,11 +32,13 @@
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public abstract class DistanceManager {
    private static final Logger LOGGER = LogManager.getLogger();
+   private static final int ENTITY_TICKING_RANGE = 2;
    private static final int PLAYER_TICKET_LEVEL;
+   private static final int INITIAL_TICKET_LIST_CAPACITY = 4;
    private final Long2ObjectMap<ObjectSet<ServerPlayer>> playersPerChunk = new Long2ObjectOpenHashMap();
    private final Long2ObjectOpenHashMap<SortedArraySet<Ticket<?>>> tickets = new Long2ObjectOpenHashMap();
    private final DistanceManager.ChunkTicketTracker ticketTracker = new DistanceManager.ChunkTicketTracker();
    private final DistanceManager.FixedPlayerDistanceChunkTracker naturalSpawnChunkCounter = new DistanceManager.FixedPlayerDistanceChunkTracker(8);
    private final DistanceManager.PlayerTicketTracker playerTicketManager = new DistanceManager.PlayerTicketTracker(33);
@@ -91,12 +98,12 @@
       boolean var3 = var2 != 0;
       if (var3) {
       }
 
       if (!this.chunksToUpdateFutures.isEmpty()) {
-         this.chunksToUpdateFutures.forEach((var1x) -> {
-            var1x.updateFutures(var1);
+         this.chunksToUpdateFutures.forEach((var2x) -> {
+            var2x.updateFutures(var1, this.mainThreadExecutor);
          });
          this.chunksToUpdateFutures.clear();
          return true;
       } else {
          if (!this.ticketsToRelease.isEmpty()) {
@@ -235,10 +242,51 @@
 
    public String getDebugStatus() {
       return this.ticketThrottler.getDebugStatus();
    }
 
+   private void dumpTickets(String var1) {
+      try {
+         FileOutputStream var2 = new FileOutputStream(new File(var1));
+         Throwable var3 = null;
+
+         try {
+            ObjectIterator var4 = this.tickets.long2ObjectEntrySet().iterator();
+
+            while(var4.hasNext()) {
+               Long2ObjectMap.Entry var5 = (Long2ObjectMap.Entry)var4.next();
+               ChunkPos var6 = new ChunkPos(var5.getLongKey());
+               Iterator var7 = ((SortedArraySet)var5.getValue()).iterator();
+
+               while(var7.hasNext()) {
+                  Ticket var8 = (Ticket)var7.next();
+                  var2.write(("" + var6.x + "\t" + var6.z + "\t" + var8.getType() + "\t" + var8.getTicketLevel() + "\t\n").getBytes(StandardCharsets.UTF_8));
+               }
+            }
+         } catch (Throwable var17) {
+            var3 = var17;
+            throw var17;
+         } finally {
+            if (var2 != null) {
+               if (var3 != null) {
+                  try {
+                     var2.close();
+                  } catch (Throwable var16) {
+                     var3.addSuppressed(var16);
+                  }
+               } else {
+                  var2.close();
+               }
+            }
+
+         }
+      } catch (IOException var19) {
+         LOGGER.error((Object)var19);
+      }
+
+   }
+
    static {
       PLAYER_TICKET_LEVEL = 33 + ChunkStatus.getDistance(ChunkStatus.FULL) - 2;
    }
 
    class ChunkTicketTracker extends ChunkTracker {
@@ -411,7 +459,44 @@
       }
 
       public void runAllUpdates() {
          this.runUpdates(Integer.MAX_VALUE);
       }
+
+      private void dumpChunks(String var1) {
+         try {
+            FileOutputStream var2 = new FileOutputStream(new File(var1));
+            Throwable var3 = null;
+
+            try {
+               ObjectIterator var4 = this.chunks.long2ByteEntrySet().iterator();
+
+               while(var4.hasNext()) {
+                  Long2ByteMap.Entry var5 = (Long2ByteMap.Entry)var4.next();
+                  ChunkPos var6 = new ChunkPos(var5.getLongKey());
+                  String var7 = Byte.toString(var5.getByteValue());
+                  var2.write(("" + var6.x + "\t" + var6.z + "\t" + var7 + "\n").getBytes(StandardCharsets.UTF_8));
+               }
+            } catch (Throwable var16) {
+               var3 = var16;
+               throw var16;
+            } finally {
+               if (var2 != null) {
+                  if (var3 != null) {
+                     try {
+                        var2.close();
+                     } catch (Throwable var15) {
+                        var3.addSuppressed(var15);
+                     }
+                  } else {
+                     var2.close();
+                  }
+               }
+
+            }
+         } catch (IOException var18) {
+            DistanceManager.LOGGER.error((Object)var18);
+         }
+
+      }
    }
 }
